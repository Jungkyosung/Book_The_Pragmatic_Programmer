## 동시성(Concurrency)

'동시성'은 둘 이상의 코드 조각이 실행될 때 동시에 실행 중인 것처럼 행동하는 것.
'병렬성'은 실제로 동시에 실행되는 것.

동시성을 얻으려면 실행 중에 코드의 다른 부분으로 실행을 전환할 수 있는 환경에서 코드를 구동해야 함.  
보통은 파이버나 스레드, 프로세스 등을 사용하여 동시성을 구현.  

병렬성을 얻으려면 두 가지 일을 동시에 할 수 있는 하드웨어가 필요.  
CPU 하나에 있는 여러 개의 코어일 수도 있고, 컴퓨터 한 대에 있는 여러 CPU이거나 아니면 네트워크로 연결된 여러 대의 컴퓨터일 수도 있다.  

#### 모든 일에 동시성이 있다

시스템 규모가 어느 정도 커지면 동시성을 고려해서 코드를 작성해야 한다.  
동시성이 겉으로 드러날 때도 있지만 라이브러리 안에 묻혀 있는 경우도 있다.  

개발자들이 고려하는 결합 중에 의존성이 있고, 의존성이 어떻게 코드를 바꾸기 어렵게 하는지를 문제로 여긴다.  
또 하나의 결합으로 '시간적 결합'이 있다.  

동시성이나 병렬성을 지원하는 코드를 사용하는 건 어렵다.  
그 이유는 프로그래밍을 순차적 시스템으로 배운 것과 '공유 상태' 때문이다.  
공유 상태란 둘 이상의 코드 뭉치가 하나의 변경 가능한 데이터를 참조하고 있다면 공유상태가 존재하는 것이다.  

동시에 혹은 병렬로 작동하는 코드가 이젠 필수다.  

---
#### Topic 33. 시간적 결합 깨트리기

소프트웨어의 설계 요소로서 시간의 역할에 대해 이야기 해보자.  
시간에는 우리가 신경 써야 할 측면이 두 가지 있다.  
- 동시성(동시에 일어나는 일들)
- 순서(시간의 흐름 속에서 일들의 상대적인 위치)

**동시성 찾기**

많은 프로젝트에서 설계 과정의 일환으로 애플리케이션의 작업 흐름을 모델화하고 분석하는 작업이 필요하다.  
우리는 동시에 일어나도 되는 게 뭐고, 반드시 순서대로 일어나야 하는 건 어떤 것인지 찾아내길 원한다.  
'활동 다이어그램' 같은 표기법을 사용해서 작업 흐름을 기록하는 것도 방법이다. like UML

활동 다이어그램을 사용해서 동시에 수행할 수 있는 처리를 찾아서 병렬성을 극대화 해라.  

**동시 작업의 기회**

활동 다이어그램을 통해 동시에 할 수 있는지를 확인할 수 있다.  
하지만 동시에 하는 것이 좋은지는 알 수 없다.  

그래서 설계가 필요하다.  
오래 걸리는 처리에 동시성을 활용하여 다른 처리들을 동시에 처리하도록 하여 효율을 높일 수 있다.  

우리 코드가 아닌 곳에서 시간이 걸리는 활동을 찾고 싶다.  
데이터베이스를 조회할 때나 외부 서비스에 접근할 때, 사용자 입력을 기다릴 때 같은 작업들에 동시처리를 통해 다른 작업들을 할 수 있다.  

**병렬 작업의 기회**

동시성은 소프트웨어 동작 방식이고, 병렬성은 하드웨어가 하는 것이다.  

독립적인 부분을 나누어 처리할 수 있다면(멀티 프로세서 환경 등), 시간을 단축할 수 있다.  
다른 부분 작업을 기다릴 필요 없이 진행할 수 있으면 좋다.  

---
#### Topic 34. 공유 상태는 틀린 상태

공유 상태 때문에 병렬처리를 할 수 없다.  

**세마포어 및 다른 상호 배제 방법**

세마포어는 단순히 한 번에 한 사람만이 가질 수 있는 무언가다.  
세마포어를 만들어서 다른 리소스의 사용을 제어하는 데 쓸 수 있다.  
세마포어를 획득하는 작업을 보통 잠금 lock / 잠금해제 unlock, 획득 claim / 반환 release로 불린다. 

```
case_semaphore.lock()

if display_case.pie_count > 0
  promise_pie_to_customer()
  display_case.take_pie()
  give_pie_to_customer()
end

case_semaphore.unlock()
```

위 코드는 이미 세마포어가 만들어져서 case_semaphore 변수에 저장되어 있다고 가정한다.  

두 종업원이 동시에 시도해도 한 종업원만 성공한다. 다른 종업원은 기다리게 된다.  

이 접근 방식의 문제 중 가장 큰 문제는 모든 사람이 세마포어를 사용해야만 제대로 동작된다는 것이다.  

**리소스를 트랜잭션으로 관리하라**

현재의 설계가 미흡한 이유 : 제어를 사용자에게 전가하기 때문.  
제어를 집중시켜야 한다.  
그러면 API를 바꿔서 종업원이 하나의 호출로 파이 조각 수를 확인함과 동시에 파이 조각을 가져가도록 만들어야 함.  

```
slice = display_case.get_pie_if_available()
if slice
  give_pie_to_customer()
end
```

이렇게 하려면 실행되는 메서드를 진열장 자체에 넣어야 한다.  

```
//틀린 코드
def get_pie_if_available()
  if @slices.size > 0
    update_sales_data(:pie)
    return @slices.shift
  else
    return false
  end
end
```

이 코드는 흔한 오해를 보여준다.  
리소스 접근을 한 곳으로 모으긴 했다. 하지만 이 메서드 자체도 여러 개의 스레드에서 동시에 호출될 수 있으므로 여전히 세마포어로 보호해야 한다.  

```
def get_pie_if_available()
  @case_semaphore.lock()

  if @slices.size > 0
    update_sales_data(:pie)
    return @slices.shift
  else
    return false
  end

  @case_semaphore.unlock()
end
```

하지만 이 코드 역시 문제가 있다.  
만약 update_sales_data가 예외를 발생시키면 세마포어는 영영 잠금이 풀리지 않을 것이고, 이후로 진열장에 접근하면 하염없이 기다리게 될 것이다.

```
def get_pie_if_available()
  @case_semaphore.lock()

  try {
    if @slices.size > 0
      update_sales_data(:pie)
      return @slices.shift
    else
      return false
    end
  }
  ensure {
    @case_semaphore.unlock()
  }
end
```

이런 실수가 너무 흔하다 보니 많은 언어에서 이런 상황을 처리해주는 라이브러리를 제공한다. 

```
def get_pie_if_available()
  @case_semaphore.protect() {
    if @slices.size > 0
      update_sales_data(:pie)
      return @slices.shift
    else
      return false
    end
  }
end
```

**여러 리소스와 트랜잭션**

레스토랑에서 아이스크림 냉동고를 설치했다. 고객이 파이 위에 아이스크림을 얹은 디저트인 '파이 알라모드'를 주문하면 종업원은 파이와 아이스크림이 둘 다 있는지 확인해야 한다.  

```
slice = display_case.get_pie_if_available()
scoop = freezer.get_ice_cream_if_available()

if slice && scoop
  give_order_to_customer()
end
```

하지만 이 코드의 문제는 파이나 아이스크림 중 하나가 없다면 계속해서 대기할 수 있다.  

이 문제는 진열장에 파이 조각을 다시 반환하는 메서드를 추가하여 해결할 수 있다.  
문제가 발생했을 때 리소스를 계속 차지하고 있지 않도록 예외 처리를 추가해야 할 것이다.  

```
slice = display_case.get_pie_if_available()  //비즈니스 로직

if slice
  try {
    scoop = freezer.get_ice_cream_if_available()  //비즈니스 로직
    if scoop
      try {
        give_order_to_customer()  //비즈니스 로직
      }
      rescue {
        freezer.give_back(scoop)
      }
    end
  }
  rescue {
    display_case.give_back(slice)
  }
end
```

여전히 이상적인 코드는 아니다. 코드가 정말 지저분하고 실제로 무슨 일을 하는지 알아보기 어렵다.  
비즈니스 로직이 이런저런 관리를 위한 코드 속에 파묻혔다.  

앞의 예에서는 리소스 관리 코드를 리소스 클래스 안으로 옮겨서 이런 문제를 해결했다.  
하지만 리소스가 두 가지다. 코드를 진열장으로 옮겨야 할까, 아니면 냉동고로 옮겨야 할까?  
**둘 다 답이 아니다.**  
실용주의적인 접근 방법은 '애플파이 알라모드'자체도 리소스로 보는 것이다.  
이 코드를 새로운 모듈로 옮기고, 클라이언트는 그냥 "아이스크림 올린 애플파이 주세요"라고 요청할 수 있어야 한다.  

물론 실제 상황에서는 이런 조합 메뉴가 더 많이 있을 것이고, 메뉴마다 새로운 모듈을 만들고 싶지는 않을 것이다.  
그 대신, 자신의 구성 요소에 대한 참조들을 갖고 있는 메뉴 항목이 있고, 또 그 구성 요소 각각이랑 자원을 주고받는 춤을 추는? 일반화된 get_menu_item메서드가 있는 편이 나을 것이다.  

**트랜잭션이 없는 갱신**

"불규칙한 실패는 동시성 문제인 경우가 많다."

**그 밖의 독점적인 접근**

대부분의 언어에는 공유 리소스에 독점적으로 접근하는 것을 도와주는 라이브러리가 있다.  
상호 배제를 의미하는 뮤텍스라고 부르기도 하고, 모니터나 세마포어라고 부르기도 한다.  

언어 자체에 동시성 자원이 들어 있는 언어도 있다.  
예를 들어 러스트는 데이터의 소유권이라는 개념을 강제한다.  
변경 가능한 데이터 조각은 어느 한 시점에 단 하나의 변수나 매개 변수만 참조를 가질 수 있다.  

함수형 언어들은 모든 데이터를 변경 불가능하게 만드는 경향이 있으므로 동시성 문제를 단순하게 만든다고 주장할 수도 있겠다.  
(?그렇다고 생각했었음. 아닌가?)  
하지만 함수형도 언젠가는 모든 것이 변경 가능한 진짜 세상에 발을 들여야 하므로 똑같은 문제를 겪는 순간이 올 것이다.  

---
#### Topic 35. 액터와 프로세스

액터와 프로세스를 사용하면 흥미로운 방식으로 동시성을 구현할 수 있다.  
공유 메모리 접근을 동기화하느라 고생할 필요도 없다.  

- '액터'는 자신만의 비공개 지역 상태를 가진 독립적인 가상 처리 장치다. 각 액터는 우편함을 하나씩 보유하고 있다. 액터가 잠자고 있을 때 우편함에 메시지가 도착하면 액터가 깨어나면서 메시지를 처리한다. 처리가 끝나면 우편함의 다른 메시지를 처리한다. 만약 우편함이 비어있으면 다시 잔다. 메시지를 처리할 때 액터는 다른 액터를 생성하거나, 알고 있는 다른 액터에게 메시지를 보내거나, 다음 메시지를 처리할 떄의 상태가 될 새로운 상태를 생성할 수 있다.
- '프로세스'는 본래 더 일반적인 가상 처리기로, 보통 운영체제가 동시성을 지원하기 위하여 구현한다. 프로세스를 사용할 때 마치 액터처럼 동작하도록 관례를 만들어 제한적으로만 사용할 수도 있는데, 이번 항목에서 이야기하는 프로세스란 바로 이렇게 제한한 것이다.

**액터는 언제나 동시성을 띤다**

액터의 정의에서 찾아볼 수 없는 것이 몇가지 있다.
- 액터를 관리하는 것이 하나도 없다. 다음에 무엇을 하라고 계획을 세우거나, 정보를 입력데이터에서 최종 결과로 바꾸는 과정을 조율하는 것이 없다.
- 시스템이 저장하는 상태는 오직 메시지 그리고 각 액터의 지역 상태뿐이다. 메시지는 수신자가 읽는 것 외에는 확인할 방법이 없고, 지역 상태는 액터 바깥에서는 접근이 불가능하다.
- 모든 메시지는 일방향이다. 답장이란 개념은 없다. 액터에서 답장을 받고 싶다면 처음 메시지를 보낼 때 답장 받을 우편함 주소를 메시지에 포함해서 보내야 한다. 나중에 이 주소로 보내는 답장도 결국 또 하나의 메시지일 뿐이다.
- 액터는 각 메시지를 끝날 때까지 처리하고 중간에 다른 일을 하지 않는다. 즉, 한 번에 하나의 메시지만 처리한다.

그 결과 액터들은 아무것도 공유하지 않으면서 비동기적으로 동시에 실행된다.  
물리적인 프로세서가 넉넉하다면 각각 액터를 하나씩 돌릴 수 있다.  
프로세서가 하나뿐이라면 실행 환경이 액터마다 컨텍스트를 전환해 가면서 실행시킬 수 있다.  
어느 쪽이든 액터에서 실행되는 코드는 동일하다.  

"공유 상태 없는 동시성을 위하여 액터를 사용하라."

**간단한 액터**

레스토랑 예시로 액터를 구현해 보자.  
고객, 종업원, 진열장 세 개의 액터가 있다.  

- 고객에게 파이가 먹고 싶게 한다.(외부에서 조종)
- 고객은 종업원에게 파이를 주문한다.
- 종업원은 고객에게 파이를 주라고 진열장에게 요청한다.
- 진열장에 파이가 있으면 파이 한 조각을 고객에게 보낸다. 종업원에게도 계산서에 추가하라고 알려준다.
- 파이가 없으면 종업원에게 알려준다. 종업원은 고객에게 양해를 구한다.

자바스크립트와 Node.js용 액터 라이브러리인 Nact를 이용하여 구현해보자.  
우리는 단순한 자바스크립트 객체로 액터를 생성하는 간단한 래퍼 함수도 따로 추가했다.  
자바스크립트의 객체는 맵처럼 사용할 수 있는데, 객체의 키에 액터가 받을 메시지를 지정하고, 값에 해당 메시지가 도착했을 때 실행할 함수를 지정한다.  
이 객체를 래퍼 함수에 넘기면 액터를 만들어 준다.  
대부분의 액터 시스템이 유사한 구조를 갖는데 세부 사항은 구현 언어에 따라 다르다.  

고객부터 시작해보자.
- 당신은 파이가 먹고 싶다. (외부에서 보냄)
- 테이블에 파이가 있습니다. (진열장이 보냄)
- 죄송합니다. 파이가 다 떨어졌습니다. (종업원이 보냄)

```js
const customerActor = {
  '파이가 먹고 싶다' : (msg, ctx, state) => {
    return dispatch(state.waiter,
                      { type: '주문', customer: ctx.self, wants: '파이' })
  },
  '테이블에 놓다' : (msg, ctx, _state) =>
    console.log(`${ctx.self.name}이(가) 테이블에 나타난 "${msg.food}"을(를) 보다.`),
  '남은 파이 없음' : (_msg, ctx, _state) =>
    console.log(`${ctx.self.name}이(가) 부루퉁하다.....`)
};
```

흥미로운 부분은 '파이가 먹고 싶다' 메시지를 받을 때인데, 이때는 종업원에게 메시지를 보낸다.  
고객이 종업원 액터를 어떻게 알게 되는지는 잠시 후에 살펴보겠다.  

종업원의 코드
```js
const waiterActor = {
  '주문': (msg, ctx, state) => {
    if (msg.wants == '파이') {
      dispatch(state.pieCase,
                { type: '한 조각 꺼내기', customer: msg.customer, waiter: ctx.self });
    }
    else {
      console.log(`${msg.wants}의 주문 방법을 알 수 없습니다.`);
    }
  },

  '주문서에 추가': (msg, ctx) =>
    console.log(`종업원이 ${msg.food}을(를) ${msg.customer.name}의 주문서에 추가합니다.`),

  '오류': (msg, ctx) => {
    dispatch(msg.customer, { type: '남은 파이 없음', msg: msg.msg });
  }
};
```

종업원이 주문 메시지를 고객에게서 받으면 고객이 '파이'를 주문한 것인지 확인한다.  
파이가 맞으면 진열장에 요청을 보낸다. 이때 고객과 자신의 참조를 함께 보낸다.  

진열장은 상태를 가지고 있다. 바로 진열된 파이 조각 배열인데, 처음에 어떻게 파이를 진열장에 넣는지도 곧 설명하겠다.  
종업원에게서 한 조각 꺼내기 메시지를 받으면 남은 파이 조각이 있는지 확인한다.  
파이가 있으면 고객에게 전달하고, 종업원에게는 주문서에 기록하라고 알려준다.  
마지막으로 한 조각이 줄어든 상태를 기록한다.  

```js
const pieCaseActor = {
  '한 조각 꺼내기': (msg, context, state) => {
    if (state.slices.length == 0) {
      dispatch(msg.waiter,
        { type: '오류', msg: '남은 파이 없음', customer: msg.customer});
      return state;
    }
    else {
      var slice = state.slices.shift() + '파이 한 조각';
      dispatch(msg.customer,
                { type: '테이블에 놓다', food: slice });
      dispatch(msg.waiter,
                { type: '주문서에 추가', food: slice, customer: msg.customer });
      return state;
    }
  }
};
```

실제 상황에선 다른 액터를 동적으로 생성하는 액터로 많이 보겠지만, 여기선 단순하게 액터를 모두 수동으로 생성할 것이다.  
또한 각각의 초기상태도 넘겨줘야 한다.  
- 진열장은 처음에 갖고 있을 파이 조각 리스트를 받는다.
- 종업원에게는 진열장의 참조를 준다.
- 고객에게는 종업원의 참조를 준다.

```js
const actorSystem = start();

let pieCase = start_actor(
    actorSystem,
    'pie-case',
    pieCaseActor,
      { slices: ['사과', '복숭아', '체리'] });
let waiter = start_actor(
    actorSystem,
    'waiter',
    watierActor,
    { pieCase: pieCase });
let c1 = start_actor(actorSystem, 'customer1', customerActor, {waiter: waiter});
let c2 = start_actor(actorSystem, 'customer2', customerActor, {waiter: waiter});
```

customer1은 파이를 세 조각 주문하고, customer2는 두 조각을 주문한다.

```js
dispatch(c1, { type: '파이가 먹고 싶다' });
dispatch(c2, { type: '파이가 먹고 싶다' });
dispatch(c1, { type: '파이가 먹고 싶다' });
dispatch(c2, { type: '파이가 먹고 싶다' });
dispatch(c1, { type: '파이가 먹고 싶다' });
sleep(500)
  .then(() => {
    stop(actorSystem);
})
```


**드러나지 않는 동시성**

액터 모델에서는 동시성을 다루는 코드를 쓸 필요가 없다.  
공유된 상태가 없기 때문이다.  
명시적으로 처음부터 끝까지 "이걸 한 다음 저걸 하라"는 코드를 쓸 필요가 없다.  
액터가 수신하는 메시지에 따라 알아서 실행되기 때문이다.  

기반 아키텍처에 대해 언급할 필요도 없다.  
이렇게 구성된 컴포넌트들은 단일 프로세서든, 멀티 코어든, 여러 컴퓨터가 네트워크로 연결되어 있든 똑같이 잘 작동한다.  

**얼랭이 장을 마련하다**

얼랭 언어와 런타임은 액터 구현의 좋은 사례이다.  
비록 얼랭을 만든 사람들은 액터 모델을 처음 제안한 논문을 읽어본 적이 없다고 하지만 말이다.  
얼랭은 액터를 '프로세스'라고 부르는데 일반적인 운영 체제의 프로세스와는 다르다.  
오히려 우리가 여기서 이야기하는 액터에 더 가깝다.  
얼랭의 프로세스는 가볍기 때문에 컴퓨터 한 대에서 수백만 개를 실행시킬 수 있고, 프로세스끼리 메시지를 보내서 통신한다.  
프로세스들은 각각 격리되어 있어서 상태를 공유하지 않는다.  

이에 더해 얼랭 런타임은 프로세스의 생애 주기를 관리하는 '슈퍼비전'시스템을 구현했다.  
슈퍼비전 시스템의 슈퍼바이저는 문제가 발생하면 프로세스 하나 혹은 일련의 프로세스를 재시작하기도 한다.  
게다가 얼랭은 실행 중인 시스템의 코드를 멈추지 않고 바꾸는 핫 코드 로딩을 지원한다.  
얼랭은 세계에서 가장 신뢰성 높은 시스템들에도 쓰이며, 99.999%의 가용성을 자랑하기도 한다.  

그렇다고 얼랭 -그리고 얼랭의 후손인 엘릭서-에만 액터가 있는 것은 아니다.  
다른 대부분의 언어에도 액터 구현이 있다.  
동시에 실행되는 작업을 구현할 때 액터를 사용하라.  

---
#### Topic 36. 칠판

"칠판으로 작업 흐름을 조율하라."

**메시지 시스템과 칠판의 유사성**

일종의 메시징 시스템으로 통신하는 작고 분리된 서비스들로 애플리케이션을 구성하는 경우가 많다.  
카프카나 NATS 같은 메시징 시스템은 단순히 데이터를 A에서 B로 보내는 것보다 훨씬 많은 일을 한다.  
특히 이벤트 로그의 형태로 영속성을 제공하고, 패턴 매칭 형태로 메시지를 가져오는 것도 지원한다.  
이 말은 메시징 시스템을 칠판으로도 사용할 수 있고, 여러 액터를 실행하는 플랫폼으로도 사용할 수 있다는 것이다.  
심지어 동시에 둘 모두로 사용할 수도 있다.  

**하지만 그렇게 간단하지 않다...**

아키텍처에서 액터와 칠판, 마이크로서비스를 활용하면 애플리케이션에서 생길 수 있는 모든 종류의 동시성 문제를 예방할 수 있을 것이다.  
하지만 거기에는 비용이 따른다.  이런 접근방식을 사용하면 많은 동작이 간접적으로 일어나므로 분석이 더 힘들다.  
메시지 형식 및 API를 모아두는 중앙 저장소를 운영하면 도움이 될 것이다.  
이 저장소에서 코드나 문서까지 생성해 준다면 더욱 좋다.  
시스템에서 처리하는 메시지나 정보를 추적할 수 있는 좋은 도구도 필요할 것이다.  
유용한 기법을 하나 소개하겠다.  
특정한 비즈니스 작업처리를 시작할 때 고유한 '추적 아이디'를 만들어서 붙이는 것이다.  
그리고 해당 작업에 관여하는 모든 액터로 아이디를 전파하면, 나중에 로그 파일을 뒤져서 어떤 일이 일어났는지 재구성해 볼 수 있을 것이다.  
마지막으로 이런 종류의 시스템은 맞춰야 하는 구성 요소 수가 더 많기 때문에 배포하고 관리하기 더 까다롭다.  
하지만 그 결과 시스템이 더 잘게 쪼개지고, 전체 시스템이 아니라 개별 액터만 교체하여 시스템을 업데이트 할 수 있다는 면에서 어느 정도 보상 받는다.

(연습문제)
다음 애플리케이션 가운데, 칠판 시스템이 적합한 것은 어떤 것이고 적합하지 않은 것은 어떤 것인가? 그리고 그 이유는 무엇인가?  

이미지 처리 - 한 이미지의 일부를 가져다가 처리한 다음 처리가 완료된 부분을 돌려주는 프로세스 여러 개를 병렬로 작동시키고 싶다.  
그룹 일정 관리 - 전 세계의 흩어져 있고, 표준 시간대도 다르고, 사용하는 언어도 다른 사람들이 회의 일정을 정할 수 있도록 해 주어야 한다.  
네트워크 감시 도구 - 이 시스템은 성능 통계 자료를 수집하고 문제 발생 기록을 모은다. 모은 정보는 에이전트가 시스템의 문제점을 찾을 때 사용한다.  


