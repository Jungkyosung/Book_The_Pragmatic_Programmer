## 동시성(Concurrency)

'동시성'은 둘 이상의 코드 조각이 실행될 때 동시에 실행 중인 것처럼 행동하는 것.
'병렬성'은 실제로 동시에 실행되는 것.

동시성을 얻으려면 실행 중에 코드의 다른 부분으로 실행을 전환할 수 있는 환경에서 코드를 구동해야 함.  
보통은 파이버나 스레드, 프로세스 등을 사용하여 동시성을 구현.  

병렬성을 얻으려면 두 가지 일을 동시에 할 수 있는 하드웨어가 필요.  
CPU 하나에 있는 여러 개의 코어일 수도 있고, 컴퓨터 한 대에 있는 여러 CPU이거나 아니면 네트워크로 연결된 여러 대의 컴퓨터일 수도 있다.  

#### 모든 일에 동시성이 있다

시스템 규모가 어느 정도 커지면 동시성을 고려해서 코드를 작성해야 한다.  
동시성이 겉으로 드러날 때도 있지만 라이브러리 안에 묻혀 있는 경우도 있다.  

개발자들이 고려하는 결합 중에 의존성이 있고, 의존성이 어떻게 코드를 바꾸기 어렵게 하는지를 문제로 여긴다.  
또 하나의 결합으로 '시간적 결합'이 있다.  

동시성이나 병렬성을 지원하는 코드를 사용하는 건 어렵다.  
그 이유는 프로그래밍을 순차적 시스템으로 배운 것과 '공유 상태' 때문이다.  
공유 상태란 둘 이상의 코드 뭉치가 하나의 변경 가능한 데이터를 참조하고 있다면 공유상태가 존재하는 것이다.  

동시에 혹은 병렬로 작동하는 코드가 이젠 필수다.  

---
#### Topic 33. 시간적 결합 깨트리기

소프트웨어의 설계 요소로서 시간의 역할에 대해 이야기 해보자.  
시간에는 우리가 신경 써야 할 측면이 두 가지 있다.  
- 동시성(동시에 일어나는 일들)
- 순서(시간의 흐름 속에서 일들의 상대적인 위치)

**동시성 찾기**

많은 프로젝트에서 설계 과정의 일환으로 애플리케이션의 작업 흐름을 모델화하고 분석하는 작업이 필요하다.  
우리는 동시에 일어나도 되는 게 뭐고, 반드시 순서대로 일어나야 하는 건 어떤 것인지 찾아내길 원한다.  
'활동 다이어그램' 같은 표기법을 사용해서 작업 흐름을 기록하는 것도 방법이다. like UML

활동 다이어그램을 사용해서 동시에 수행할 수 있는 처리를 찾아서 병렬성을 극대화 해라.  

**동시 작업의 기회**

활동 다이어그램을 통해 동시에 할 수 있는지를 확인할 수 있다.  
하지만 동시에 하는 것이 좋은지는 알 수 없다.  

그래서 설계가 필요하다.  
오래 걸리는 처리에 동시성을 활용하여 다른 처리들을 동시에 처리하도록 하여 효율을 높일 수 있다.  

우리 코드가 아닌 곳에서 시간이 걸리는 활동을 찾고 싶다.  
데이터베이스를 조회할 때나 외부 서비스에 접근할 때, 사용자 입력을 기다릴 때 같은 작업들에 동시처리를 통해 다른 작업들을 할 수 있다.  

**병렬 작업의 기회**

동시성은 소프트웨어 동작 방식이고, 병렬성은 하드웨어가 하는 것이다.  

독립적인 부분을 나누어 처리할 수 있다면(멀티 프로세서 환경 등), 시간을 단축할 수 있다.  
다른 부분 작업을 기다릴 필요 없이 진행할 수 있으면 좋다.  

---
#### Topic 34. 공유 상태는 틀린 상태

공유 상태 때문에 병렬처리를 할 수 없다.  

**세마포어 및 다른 상호 배제 방법**

세마포어는 단순히 한 번에 한 사람만이 가질 수 있는 무언가다.  
세마포어를 만들어서 다른 리소스의 사용을 제어하는 데 쓸 수 있다.  
세마포어를 획득하는 작업을 보통 잠금 lock / 잠금해제 unlock, 획득 claim / 반환 release로 불린다. 

```
case_semaphore.lock()

if display_case.pie_count > 0
  promise_pie_to_customer()
  display_case.take_pie()
  give_pie_to_customer()
end

case_semaphore.unlock()
```

위 코드는 이미 세마포어가 만들어져서 case_semaphore 변수에 저장되어 있다고 가정한다.  

두 종업원이 동시에 시도해도 한 종업원만 성공한다. 다른 종업원은 기다리게 된다.  

이 접근 방식의 문제 중 가장 큰 문제는 모든 사람이 세마포어를 사용해야만 제대로 동작된다는 것이다.  

**리소스를 트랜잭션으로 관리하라**

현재의 설계가 미흡한 이유 : 제어를 사용자에게 전가하기 때문.  
제어를 집중시켜야 한다.  
그러면 API를 바꿔서 종업원이 하나의 호출로 파이 조각 수를 확인함과 동시에 파이 조각을 가져가도록 만들어야 함.  

```
slice = display_case.get_pie_if_available()
if slice
  give_pie_to_customer()
end
```

이렇게 하려면 실행되는 메서드를 진열장 자체에 넣어야 한다.  

```
//틀린 코드
def get_pie_if_available()
  if @slices.size > 0
    update_sales_data(:pie)
    return @slices.shift
  else
    return false
  end
end
```

이 코드는 흔한 오해를 보여준다.  
리소스 접근을 한 곳으로 모으긴 했다. 하지만 이 메서드 자체도 여러 개의 스레드에서 동시에 호출될 수 있으므로 여전히 세마포어로 보호해야 한다.  

```
def get_pie_if_available()
  @case_semaphore.lock()

  if @slices.size > 0
    update_sales_data(:pie)
    return @slices.shift
  else
    return false
  end

  @case_semaphore.unlock()
end
```

하지만 이 코드 역시 문제가 있다.  
만약 update_sales_data가 예외를 발생시키면 세마포어는 영영 잠금이 풀리지 않을 것이고, 이후로 진열장에 접근하면 하염없이 기다리게 될 것이다.

```
def get_pie_if_available()
  @case_semaphore.lock()

  try {
    if @slices.size > 0
      update_sales_data(:pie)
      return @slices.shift
    else
      return false
    end
  }
  ensure {
    @case_semaphore.unlock()
  }
end
```

이런 실수가 너무 흔하다 보니 많은 언어에서 이런 상황을 처리해주는 라이브러리를 제공한다. 

```
def get_pie_if_available()
  @case_semaphore.protect() {
    if @slices.size > 0
      update_sales_data(:pie)
      return @slices.shift
    else
      return false
    end
  }
end
```

**여러 리소스와 트랜잭션**

**트랜잭션이 없는 갱신**

---
#### Topic 35. 액터와 프로세스

액터와 프로세스를 사용하면 흥미로운 방식으로 동시성을 구현할 수 있다.  
공유 메모리 접근을 동기화하느라 고생할 필요도 없다.  

- '액터'는 자신만의 비공개 지역 상태를 가진 독립적인 가상 처리 장치다. 각 액터는 우편함을 하나씩 보유하고 있다. 액터가 잠자고 있을 때 우편함에 메시지가 도착하면 액터가 깨어나면서 메시지를 처리한다. 처리가 끝나면 우편함의 다른 메시지를 처리한다. 만약 우편함이 비어있으면 다시 잔다. 메시지를 처리할 때 액터는 다른 액터를 생성하거나, 알고 있는 다른 액터에게 메시지를 보내거나, 다음 메시지를 처리할 떄의 상태가 될 새로운 상태를 생성할 수 있다.
- '프로세스'는 본래 더 일반적인 가상 처리기로, 보통 운영체제가 동시성을 지원하기 위하여 구현한다. 프로세스를 사용할 때 마치 액터처럼 동작하도록 관례를 만들어 제한적으로만 사용할 수도 있는데, 이번 항목에서 이야기하는 프로세스란 바로 이렇게 제한한 것이다.

- **액터는 언제나 동시성을 띤다**

- 액터의 정의에서 찾아볼 수 없는 것이 몇가지 있다.
- - 액터를 관리하는 것이 하나도 없다. 다음에 무엇을 하라고 계획을 세우거나, 정보를 입력데이터에서 최종 결과로 바꾸는 과정을 조율하는 것이 없다.
  - 





