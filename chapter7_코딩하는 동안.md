일단 코딩에 들어가면 대부분 기계적인 작업, 즉 설계 내용을 컴퓨터가 실행할 수 있는 문장으로 바꾸는 일만 하면 된다고들 많이 생각한다.(SI 작업 방식)  
이런 태도가 소프트웨어 프로젝트가 실패하는 가장 큰 원인이다.  
이런 태도 때문에 많은 시스템이 결국 너저분해지고, 비효율적이 되고, 구조가 망가지고, 유지 보수가 힘들어지고, 망가지게 된다.  

코딩은 기계적인 작업이 아니다. 그랬다면 1980년대 초반에 수많은 사람이 기대를 걸었던 CASE 도구들이 이미 오래전에 프로그래머를 대체했을 것이다.  
코딩할 때는 매 순간 결정을 내려야 하는데, 프로그램이 정확하게 생산적으로 작동하면서 천수를 누리도록 하려면 사려 깊은 생각과 판단으로 결정을 내려야 한다.  

#### Topic 37. 파충류의 뇌에 귀 기울이기

우리가 본능적으로 느껴지는 느낌에 귀 기울여서 왜 그런 느낌이 드는지 알아내야 한다. 그런 본능에서 불안하고 초조하고 감당하기 어려운 일 처럼 느껴지는 부분들이 있다.  

**백지의 공포**

누구나 텅 빈 화면을 두려워 한다.  
새로운 프로젝트를 시작하는 일도 두렵기는 마찬가지다.  
이미 있는 프로젝트에 새로운 모듈을 추가하는 일도 그렇다.  
많은 사람이 일을 시작하는 첫 발짝을 미루고 싶어 한다.  

이 문제의 두 가지 원인
1. 파충류의 뇌가 여러분에게 무언가 할 말이 있어서다. 의심이 생겨서다.
2. 실수할까봐 두려운 것일 수 있다.

**자신과 싸우기**

가끔은 코드가 잘 써지고, 가끔은 굉장히 힘들게 느껴진다.  
힘들게 느껴지는 이유는 아마 무의식적으로 잘못된 길을 가고 있어서 일 수 있다.  

**파충류와 이야기하는 법**

결국 본인의 무의식에 귀 기울여야 한다.

하던 일에 매몰되지 말고 그런 느낌이 오면 멈춰서 생각해봐라.  
뇌가 정리할 시간과 공간을 주자.  
코드에 대해 생각하지 말고 머리를 비운 채로 할 수 있는 일을 하라.  
산책, 수다, 잠 등 천천히 생각하자.  

이 방법이 잘 안되면 문제를 표면으로 끄집어내 보라.  
작성하는 코드에 대한 그림을 그려보기도 하고, 동료에게 설명도 하고, 프로그래머가 아닌 사람에게도 설명하고, 이런 과정을 통해 문득 깨닫게 될 수 있다.  

이래도 안되면 이제 행동해야 할 시간이다. 프로토타이핑을 만들자!

프로토타이핑 실천법
1. 포스트잇에 "프로토타이핑 중"이라고 써서 모니터 옆에 붙여라.
2. 프로토타이핑은 원래 실패한다고 자신에게 상기시켜라. 실패하지 않더라도 프로토타입은 버리는 것이라는 점도 함께 상기시켜라. 프로토타이핑으로 손해볼 일은 없다.
3. 텅 빈 에디터 화면에 여러분이 배우고 싶은 것 혹은 하고 싶은 것을 한 문장의 주석으로 표현해 보라.
4. 코딩을 시작하라.

꺼림칙했던 느낌이 코딩 도중에 갑자기 명확한 문제로 구체화 되면 즉각 해결하라.  

실험을 끝마쳤는데도 여전히 불안한 마음이 들면 다시 처음부터 시작하라.  
첫 단계는 산책과 수다, 그리고 휴식이다.  

**'여러분'의 코드뿐이 아니다.**

우리 일의 상당 부분은 기존 코드를 다루는 것이다.  
사람들은 저마다 다른 본능을 가지고 있으므로 여러분과는 다른 결정들을 내렸을 것이다.  

**코드뿐이 아니다**

직감에 귀 기울이는 방법은 계속 갈고닦아야 할 중요한 기술이다.  
그런데 이 기술은 더 많은 일에 적용할 수 있다.  
설계나 요구사항이 불편하게 느껴질 수도 있다.  
그 느낌을 분석하라.  

#### Topic 38. 우연에 맡기는 프로그래밍

우연한 성공에 의존하는 프로그래밍을 하지 않아야 한다. 대신 '의도적으로 프로그래밍'해야 한다.

코딩을 하면서 왜 잘 돌아가는지 모르고 코드를 계속해서 덧붙이면서 코딩을 하면 갑자기 프로그램이 돌아가지 않을 때 왜 그런지 모른다.  
왜 코드가 망가졌는지 모르는 이유는 **애초에 코드가 왜 잘 돌아가는지도 몰랐기 때문이다.**

**구현에서 생기는 우연**

단순히 코드가 지금 작성된 방식이 그렇기 때문에 생기는 우연한 일들이 있다.  
이런 우연에 기대다 보면 결국 문서화되지 않은 에러나 예외적인 경우의 동작에 의존하게 되고 만다.  

예를 들어 어떤 루틴을 잘못된 데이터를 가지고 호출했다고 보자.  
루틴은 예상하지 못한 데이터에 특정한 방식으로 반응을 하고, 여러분은 그 반응을 기반으로 코드를 작성한다.  
하지만 루틴을 만든 사람의 의도는 그 루틴이 그런 식으로 작동하는 것이 아니었다.  
만든 사람이 생각조차 못했던 경우인 것이다.  
이 루틴을 '고치면' 여러분의 코드는 작동을 멈출지도 모른다.  

가장 극단적인 경우는 여러분이 호출한 루틴이 실제로는 그렇게 설계된 루틴이 아닌데도 여러분이 원하는 효과를 내는 것처럼 보일 수 있다.  
잘못된 순서로 호출하거나, 잘못된 맥락에서 호출하는 것도 이와 관련한 문제다.  

프레드가 GUI 렌더링 프레임워크를 사용하여 화면에 무엇인가 출력하기 위해 필사적으로 노력했던 흔적을 보자.  

```
paint();
invalidate();
validate();
revalidate();
repaint();
paintImmediately();
```

하지만 여기 나온 루틴들은 결코 이런 식으로 호출하도록 설계되지 않았으므로 지금은 작동하는 것처럼 보여도 그것은 단지 우연일 뿐이다.  

상처에 소금을 뿌리는 격으로 마침내 화면이 그려지더라도 프레드는 코드로 돌아가 불필요한 호출을 제거하지 않는다.

**"이제 돌아는 가니까, 그대로 놔두는 편이 더 나을 거야..."(굉장히 자주 일어나는 상황이라 조심해야 함)**

잘 작동하는 데 괜히 건드려서 일을 만들 필요가 있을까싶다.

- 정말로 제대로 돌아가는 게 아닐지도 모른다. 그저 돌아가는 듯이 보이는 것일 수도 있다.
- 여러분이 의존하는 조건이 우연일 수 있다.
- 문서화되지 않은 동작은 라이브러리의 다음 릴리스에서 변경될 수도 있다.
- 불필요한 추가 호출은 코드를 더 느리게 만든다.
- 추가로 호출한 루틴에 새로운 버그가 생길 수도 있다.

다른 사람이 호출할 코드를 작성하고 있다면 모듈화를 잘하는 것, 그리고 잘 문서화한 적은 수의 인터페이스 아래에 구현을 숨기는 것 같은 기본 원칙들이 모두 도움이 된다.  
다른 루틴을 호출할 때도 문서화된 동작에만 의존하라. 어떤 이유로든 그럴 수 없다면 추측을 문서로 상세히 남겨라.  

우리는 생각보다 많은 우연에 의존하고 있다.  
구현하는 프로그램이 디렉터리에 쓸 수 있다는 것에 의존하고 있지 않은가?  
어떤 환경 변수나 설정 파일이 존재한다는 것은?  
서버의 시간이 정확하다는 것은?  
인터넷 검색으로 찾은 첫 번째 답에서 코드를 복사해 올 때 여러분과 동일한 상황이라고 확신하는가? 아니면 그냥 따라하는 '화물숭배'코드를 만들고 있나?  

잘 되는 듯한 답을 찾는 것과 올바른 답을 찾는 것은 다르다.  

우연은 여러 단계에서 우리를 오도할 수 있다.  
요구 사항을 만들어내는 단계부터 테스팅에 이르기까지 이 모든 단계에서 우연이 발생한다.  
테스트가 특히 가짜 원인과 우연한 결과로 가득 찬 영역이다.  
X의 원인은 Y라고 가정하기는 쉽다. 하지만 가정하지 말고 증명하라.  

모든 차원에서 사람들은 마음속에 많은 가정을 품고 작업한다.  
하지만 이런 가정을 문서화하는 경우는 드물며 개발자마다 가정이 다를 때도 많다.  
확고한 사실에 근거하지 않은 가정은 어떤 프로젝트에서든 재앙의 근원이 된다.  

**의도적으로 프로그래밍하기**

- 지금 무엇을 하고 있는지 알아야 한다.
- 경험이 적은 동료에게 코드를 상세히 설명할 수 있는가?
- 자신도 잘 모르는 코드를 만들지 마라. 왜 동작하는지 모르면 왜 실패하는지도 알리가 없다.
- 계획을 세우고 그것을 바탕으로 진행하라.
- 신뢰할 수 있는 것에만 기대라. 가정에 의존하지 말라. 무언가를 신뢰할 수 있을지 판단하기 어렵다면 일단 최악의 상황을 가정하라.
- 가정을 기록으로 남겨라.
- 코드뿐 아니라 여러분이 세운 가정도 테스트해 보아야 한다.
- 노력을 기울일 대상의 우선순위를 정하라. 중요한 것에 먼저 시간투자하라. 중요한 부분이 가장 어려운 부분이기도 한다.
- 과거의 노예가 되지 마라. 기존 코드가 앞으로 짤 코드를 지배하도록 놓아두지 말라. 더는 적절한 코드가 아니다 싶으면 어떤 코드라도 교체할 수 있다.

(연습문제)
외부에서 들어오는 데이터에 키-값 쌍을 표현하는 튜플 배열이 들어 있다고 해 보자. 이 중 DepositAccount 키에는 계좌 번호 문자열이 값으로 들어 있어야 한다.

```
[
  ...
  {:DepositAccount, "564-904-143-00" }
  ...
]
```

개발자의 쿼드 코어 노트북과 12코어 빌드 장비에서도 잘 동작했다.  
그런데 컨테이너에서 돌아가는 실제 서비스 서버에서는 자꾸 잘못된 계좌 번호가 들어온다. 무슨 일일까?

(예상답)
이걸 어케 맞춤? 코어 개수는 왜 얘기한 거지? 


(연습문제)
여러분은 음성 알림 시스템용 자동 전화 발신 장치를 만들고 있다. 그래서 연락처 데이터베이스를 관리해야 한다.  
국제전기통신엽합에서는 전화번호가 15자리 이내여야 한다고 규정하고 있고, 여러분은 전화번호를 15자리까지 저장할 수 있는 숫자 필드에 저장하기로 했다.  
여러분은 북아메리카 전체에 걸쳐 철저하게 테스트를 마쳤고 모든 것이 괜찮아 보였다.  
그런데 갑자기 지구 반대편에서 항의가 들어온다. 왜일까?  

(예상답)
전화번호가 더 긴 나라도 존재하기 때문에 데이터베이스에 전화번호가 일부 잘려서 등록되거나 등록되지 않는 오류가 발생했을 것이다.
