일단 코딩에 들어가면 대부분 기계적인 작업, 즉 설계 내용을 컴퓨터가 실행할 수 있는 문장으로 바꾸는 일만 하면 된다고들 많이 생각한다.(SI 작업 방식)  
이런 태도가 소프트웨어 프로젝트가 실패하는 가장 큰 원인이다.  
이런 태도 때문에 많은 시스템이 결국 너저분해지고, 비효율적이 되고, 구조가 망가지고, 유지 보수가 힘들어지고, 망가지게 된다.  

코딩은 기계적인 작업이 아니다. 그랬다면 1980년대 초반에 수많은 사람이 기대를 걸었던 CASE 도구들이 이미 오래전에 프로그래머를 대체했을 것이다.  
코딩할 때는 매 순간 결정을 내려야 하는데, 프로그램이 정확하게 생산적으로 작동하면서 천수를 누리도록 하려면 사려 깊은 생각과 판단으로 결정을 내려야 한다.  

#### Topic 37. 파충류의 뇌에 귀 기울이기

우리가 본능적으로 느껴지는 느낌에 귀 기울여서 왜 그런 느낌이 드는지 알아내야 한다. 그런 본능에서 불안하고 초조하고 감당하기 어려운 일 처럼 느껴지는 부분들이 있다.  

**백지의 공포**

누구나 텅 빈 화면을 두려워 한다.  
새로운 프로젝트를 시작하는 일도 두렵기는 마찬가지다.  
이미 있는 프로젝트에 새로운 모듈을 추가하는 일도 그렇다.  
많은 사람이 일을 시작하는 첫 발짝을 미루고 싶어 한다.  

이 문제의 두 가지 원인
1. 파충류의 뇌가 여러분에게 무언가 할 말이 있어서다. 의심이 생겨서다.
2. 실수할까봐 두려운 것일 수 있다.

**자신과 싸우기**

가끔은 코드가 잘 써지고, 가끔은 굉장히 힘들게 느껴진다.  
힘들게 느껴지는 이유는 아마 무의식적으로 잘못된 길을 가고 있어서 일 수 있다.  

**파충류와 이야기하는 법**

결국 본인의 무의식에 귀 기울여야 한다.

하던 일에 매몰되지 말고 그런 느낌이 오면 멈춰서 생각해봐라.  
뇌가 정리할 시간과 공간을 주자.  
코드에 대해 생각하지 말고 머리를 비운 채로 할 수 있는 일을 하라.  
산책, 수다, 잠 등 천천히 생각하자.  

이 방법이 잘 안되면 문제를 표면으로 끄집어내 보라.  
작성하는 코드에 대한 그림을 그려보기도 하고, 동료에게 설명도 하고, 프로그래머가 아닌 사람에게도 설명하고, 이런 과정을 통해 문득 깨닫게 될 수 있다.  

이래도 안되면 이제 행동해야 할 시간이다. 프로토타이핑을 만들자!

프로토타이핑 실천법
1. 포스트잇에 "프로토타이핑 중"이라고 써서 모니터 옆에 붙여라.
2. 프로토타이핑은 원래 실패한다고 자신에게 상기시켜라. 실패하지 않더라도 프로토타입은 버리는 것이라는 점도 함께 상기시켜라. 프로토타이핑으로 손해볼 일은 없다.
3. 텅 빈 에디터 화면에 여러분이 배우고 싶은 것 혹은 하고 싶은 것을 한 문장의 주석으로 표현해 보라.
4. 코딩을 시작하라.

꺼림칙했던 느낌이 코딩 도중에 갑자기 명확한 문제로 구체화 되면 즉각 해결하라.  

실험을 끝마쳤는데도 여전히 불안한 마음이 들면 다시 처음부터 시작하라.  
첫 단계는 산책과 수다, 그리고 휴식이다.  

**'여러분'의 코드뿐이 아니다.**

우리 일의 상당 부분은 기존 코드를 다루는 것이다.  
사람들은 저마다 다른 본능을 가지고 있으므로 여러분과는 다른 결정들을 내렸을 것이다.  

**코드뿐이 아니다**

직감에 귀 기울이는 방법은 계속 갈고닦아야 할 중요한 기술이다.  
그런데 이 기술은 더 많은 일에 적용할 수 있다.  
설계나 요구사항이 불편하게 느껴질 수도 있다.  
그 느낌을 분석하라.  

#### Topic 38. 우연에 맡기는 프로그래밍

우연한 성공에 의존하는 프로그래밍을 하지 않아야 한다. 대신 '의도적으로 프로그래밍'해야 한다.

코딩을 하면서 왜 잘 돌아가는지 모르고 코드를 계속해서 덧붙이면서 코딩을 하면 갑자기 프로그램이 돌아가지 않을 때 왜 그런지 모른다.  
왜 코드가 망가졌는지 모르는 이유는 **애초에 코드가 왜 잘 돌아가는지도 몰랐기 때문이다.**

**구현에서 생기는 우연**

단순히 코드가 지금 작성된 방식이 그렇기 때문에 생기는 우연한 일들이 있다.  
이런 우연에 기대다 보면 결국 문서화되지 않은 에러나 예외적인 경우의 동작에 의존하게 되고 만다.  

예를 들어 어떤 루틴을 잘못된 데이터를 가지고 호출했다고 보자.  
루틴은 예상하지 못한 데이터에 특정한 방식으로 반응을 하고, 여러분은 그 반응을 기반으로 코드를 작성한다.  
하지만 루틴을 만든 사람의 의도는 그 루틴이 그런 식으로 작동하는 것이 아니었다.  
만든 사람이 생각조차 못했던 경우인 것이다.  
이 루틴을 '고치면' 여러분의 코드는 작동을 멈출지도 모른다.  

가장 극단적인 경우는 여러분이 호출한 루틴이 실제로는 그렇게 설계된 루틴이 아닌데도 여러분이 원하는 효과를 내는 것처럼 보일 수 있다.  
잘못된 순서로 호출하거나, 잘못된 맥락에서 호출하는 것도 이와 관련한 문제다.  

프레드가 GUI 렌더링 프레임워크를 사용하여 화면에 무엇인가 출력하기 위해 필사적으로 노력했던 흔적을 보자.  

```
paint();
invalidate();
validate();
revalidate();
repaint();
paintImmediately();
```

하지만 여기 나온 루틴들은 결코 이런 식으로 호출하도록 설계되지 않았으므로 지금은 작동하는 것처럼 보여도 그것은 단지 우연일 뿐이다.  

상처에 소금을 뿌리는 격으로 마침내 화면이 그려지더라도 프레드는 코드로 돌아가 불필요한 호출을 제거하지 않는다.

**"이제 돌아는 가니까, 그대로 놔두는 편이 더 나을 거야..."(굉장히 자주 일어나는 상황이라 조심해야 함)**

잘 작동하는 데 괜히 건드려서 일을 만들 필요가 있을까싶다.

- 정말로 제대로 돌아가는 게 아닐지도 모른다. 그저 돌아가는 듯이 보이는 것일 수도 있다.
- 여러분이 의존하는 조건이 우연일 수 있다.
- 문서화되지 않은 동작은 라이브러리의 다음 릴리스에서 변경될 수도 있다.
- 불필요한 추가 호출은 코드를 더 느리게 만든다.
- 추가로 호출한 루틴에 새로운 버그가 생길 수도 있다.

다른 사람이 호출할 코드를 작성하고 있다면 모듈화를 잘하는 것, 그리고 잘 문서화한 적은 수의 인터페이스 아래에 구현을 숨기는 것 같은 기본 원칙들이 모두 도움이 된다.  
다른 루틴을 호출할 때도 문서화된 동작에만 의존하라. 어떤 이유로든 그럴 수 없다면 추측을 문서로 상세히 남겨라.  

우리는 생각보다 많은 우연에 의존하고 있다.  
구현하는 프로그램이 디렉터리에 쓸 수 있다는 것에 의존하고 있지 않은가?  
어떤 환경 변수나 설정 파일이 존재한다는 것은?  
서버의 시간이 정확하다는 것은?  
인터넷 검색으로 찾은 첫 번째 답에서 코드를 복사해 올 때 여러분과 동일한 상황이라고 확신하는가? 아니면 그냥 따라하는 '화물숭배'코드를 만들고 있나?  

잘 되는 듯한 답을 찾는 것과 올바른 답을 찾는 것은 다르다.  

우연은 여러 단계에서 우리를 오도할 수 있다.  
요구 사항을 만들어내는 단계부터 테스팅에 이르기까지 이 모든 단계에서 우연이 발생한다.  
테스트가 특히 가짜 원인과 우연한 결과로 가득 찬 영역이다.  
X의 원인은 Y라고 가정하기는 쉽다. 하지만 가정하지 말고 증명하라.  

모든 차원에서 사람들은 마음속에 많은 가정을 품고 작업한다.  
하지만 이런 가정을 문서화하는 경우는 드물며 개발자마다 가정이 다를 때도 많다.  
확고한 사실에 근거하지 않은 가정은 어떤 프로젝트에서든 재앙의 근원이 된다.  

**의도적으로 프로그래밍하기**

- 지금 무엇을 하고 있는지 알아야 한다.
- 경험이 적은 동료에게 코드를 상세히 설명할 수 있는가?
- 자신도 잘 모르는 코드를 만들지 마라. 왜 동작하는지 모르면 왜 실패하는지도 알리가 없다.
- 계획을 세우고 그것을 바탕으로 진행하라.
- 신뢰할 수 있는 것에만 기대라. 가정에 의존하지 말라. 무언가를 신뢰할 수 있을지 판단하기 어렵다면 일단 최악의 상황을 가정하라.
- 가정을 기록으로 남겨라.
- 코드뿐 아니라 여러분이 세운 가정도 테스트해 보아야 한다.
- 노력을 기울일 대상의 우선순위를 정하라. 중요한 것에 먼저 시간투자하라. 중요한 부분이 가장 어려운 부분이기도 한다.
- 과거의 노예가 되지 마라. 기존 코드가 앞으로 짤 코드를 지배하도록 놓아두지 말라. 더는 적절한 코드가 아니다 싶으면 어떤 코드라도 교체할 수 있다.

(연습문제)
외부에서 들어오는 데이터에 키-값 쌍을 표현하는 튜플 배열이 들어 있다고 해 보자. 이 중 DepositAccount 키에는 계좌 번호 문자열이 값으로 들어 있어야 한다.

```
[
  ...
  {:DepositAccount, "564-904-143-00" }
  ...
]
```

개발자의 쿼드 코어 노트북과 12코어 빌드 장비에서도 잘 동작했다.  
그런데 컨테이너에서 돌아가는 실제 서비스 서버에서는 자꾸 잘못된 계좌 번호가 들어온다. 무슨 일일까?

(예상답)
이걸 어케 맞춤? 코어 개수는 왜 얘기한 거지? 


(연습문제)
여러분은 음성 알림 시스템용 자동 전화 발신 장치를 만들고 있다. 그래서 연락처 데이터베이스를 관리해야 한다.  
국제전기통신엽합에서는 전화번호가 15자리 이내여야 한다고 규정하고 있고, 여러분은 전화번호를 15자리까지 저장할 수 있는 숫자 필드에 저장하기로 했다.  
여러분은 북아메리카 전체에 걸쳐 철저하게 테스트를 마쳤고 모든 것이 괜찮아 보였다.  
그런데 갑자기 지구 반대편에서 항의가 들어온다. 왜일까?  

(예상답)
전화번호가 더 긴 나라도 존재하기 때문에 데이터베이스에 전화번호가 일부 잘려서 등록되거나 등록되지 않는 오류가 발생했을 것이다.

(연습문제)  
여러분은 가정용 조리법을 5,000석 규모의 크루즈선 레스토랑용 조리법으로 변환하는 프로그램을 만들었다. 하지만 변환이 정확하지 않다고 항의를 받고 있다.  
확인해 보았지만, 코드는 16컵 1갤런이라는 공식을 쓰고 있다. 정확하다. 아닌가?  

(예상답)
나라마다 사용하는 단위가 달라서 문제의 소지가 있다.

---
#### Topic 39. 알고리즘의 속도

알고리즘 속도의 질문에 대합 답에는 상식과 분석, O표기법의 근삿값을 기록하는 방식을 이용한다.  

**대문자 O 표기법**  

O가 '...차수로(order of)'를 뜻함.  
O(n^2) = 원소 수가 2배로 늘어나면 시간은 4배가 된다는 의미  

n이 커질수록 가장 큰 차수에 비하면 다른 차수는 무시해도 될 정도이기 때문에, 관습적으로 최상위 차수를 제외한 다른 모든 차수는 제거하며, 상수인 계수도 표기하지 않는다.

O(n^2/2 + 3n)은 3n인 1차수를 제외하여 O(n^2/2)와 같고, O(n^2)과도 같다.  

시간복잡도 뿐만 아니라 메모리 사용량 모델링에도 유용하다.  
O(1)  -  상수 (배열의 원소 접근, 단순 명령문)
O(lgn)  - 로그 (이진 검색) 로그의 밑은 중요치 않음
O(n)  - 선형 (순차검색)
O(nlgn)  - 성형보단 좋지 않지만, 그래도 나쁘지 않음(퀵정렬과 힙정렬의 평균 수행 시간)
O(n^2)  - 제곱 (선택 정렬과 삽입 정렬)
O(n^3) - 세제곱
O(C^n)  - 지수 (여행하는 외판원 문제, 집합 분할 문제)

**상식으로 추정하기**

상식을 이용해서 간단한 알고리즘들의 차수를 대부분 추정할 수 있다.  

- 단순 반복문 : O(n), 소진 탐색, 배열에서 최댓값 찾기, 체크섬 생성하기 등.
- 중첩 반복문 : O(n^2), 버블 정렬등 이중 for문 로직.
- 반씩 자르기 : O(lgn), 이진검색, 이진 트리 탐색 등.
- 분할 정복 : O(nlgn), 퀵 정렬, 데이터를 반으로 나누고 각 반쪽에서 재귀적으로 정렬을 수행한다.
- 조합적 : 순열 관련 로직은 겁나 느림. 원소가 늘어남에 따라 계승이 따라오면서 원소 증가 횟수가 확 늘어남.

**실전에서의 알고리즘 속도**

회사에서는 보통 정렬 루틴을 작성하기 보단 이미 있는 라이브러리의 함수를 사용한다.  
하지만 앞선 기본적인 알고리즘들이 계속해서 나타난다.  
단순 반복문을 작성할 때 O(n)인 것을 알고, 그 안에 반복문이 들어오면 O(n^2)인 걸 안다.  
입력값으로 얼마나 큰 숫자가 들어올지 스스로 물어봐서 입력될 최대값을 확인하여 어느 정도 시간이 걸릴지 확인해봐야 한다.  
커다란 수가 들어왔을 때, 수행시간이나 메모리 소모에 어떤 영향을 미칠지 생각해 보는 것이 좋다.  

잠재적인 문제점을 해결하기 위해 생각해 볼 방법들  
- O(n^2) 알고리즘이 있다면 분할 정복을 사용하여 O(nlgn)으로 줄일 수 없는지 확인하자.
- 코드의 실행시간이 얼마나 될지 또는 메모리를 얼마나 사용할지 모르겠다면 직접 해봐라. 작업 시간에 영향을 주는 변수들을 변경하면서 실행해보고 그래프를 그려서 확인해봐라. (직접적인 O() 파악)
- 어떤 일을 하는 코드인지 코드 자체에 대해서도 생각해봐라. 입력 값이 작을 경우, 단순한 O(n^2)이 복잡한 O(nlgn)보다 좋을 수 있다.
- 이론적인 부분과 실무적인 부분을 모두 파악해봐라. 실제 데이터로 파악해야 정확한 결과를 알 수 있다.(실제 입력값을 기준으로 단위 테스트 결과 확인)

**적당한 알고리즘 선택시 실용적이어야 한다**

가장 빠른 알고리즘이 가장 좋은 알고리즘은 아니다.  
'성급한 최적화'를 조심하라.  
언제나 어떤 알고리즘을 개선하느라 시간을 쏟기 전에 정말로 그것이 병목인지 확인해라.  


(연습문제)  
"상식으로 추정하기"에서 "반씩 자르기"가 O(lgn)이라고 했다. 증명할 수 있는가?  

(연습문제)  
"다양한 알고리즘의 수행시간"에서 우리는 O(lgn)이 O(log10n)과 동일하고 사실 로그의 밑이 무엇이든 모두 동일하다고 했다. 왜 그런지 설명할 수 있는가?  

---
#### Topic 40. 리팩터링

코드는 정적인 존재가 아니다. 시간에 따라 발전해야 한다.  

**리팩터링이란?** 동작은 유지한 채 내부 구조를 변경하여 코드를 재구성하는 기법.

1. 체계적이다.
2. 밖으로 드러나는 동작은 바뀌지 않는다. 기능을 추가하는 작업이 아니다.

리팩터링을 일상처럼 조금씩 일정하게 수행해야 한다. 한 번에 구조를 갈아엎는 것은 안된다.  
밖으로 드러나는 동작이 바뀌지 않는다는 것을 보장하기 위해 코드 동작을 검증하는 자동화된 단위 테스트가 필요하다.

**리팩터링은 언제 하는가?**

나의 지식이 더 늘어났을 때, 현재 코드가 더 이상 적합하지 않을 때, 뭔가 잘못됐다라는 생각이 들 때 등등
- 중복 - DRY 원칙 위배
- 직교적이지 않은 설계 - 더 직교적으로 바꿀 수 있는 무언가를 발견
- 더 이상 유효하지 않은 지식 - 코드가 지금 상황에 뒤떨어지지 않도록 개선
- 사용 사례 - 실제 시스템 사용을 보면 설계시 생각했던 것과 달리 기능들의 중요도가 바뀔 수 있다.
- 성능 - 성능을 개선하려면 시스템의 한 영역에서 다른 영역으로 기능을 옮겨야 한다. ??
- 테스트 통과 - 코드를 추가한 후 추가한 테스트가 통과했을 때, 방금 추가한 코드를 바로 깔끔하게 정리해라.

**현실 세계의 복잡한 문제들**

일정의 압박 때문에 리팩터링을 하지 않게 되는 경우가 많다.  
하지만 추후 의존성이 더 커졌을 때 리팩터링을 하게 되면 시간이 더 오래 걸린다.  
그리고 그때에도 시간은 여전히 부족할 것이다.  

"일찍 리팩터링 하고, 자주 리팩터링 하자"

**리팩터링은 어떻게 하는가?**

리팩터링의 본질은 재설계다.  
여러 가지 이유로 시간이 지나면서 이전에 설계했던 모든 것들이 재설계 대상이 될 수 있다.  
하지만 그렇다고 거대한 규모의 코드를 닥치는 대로 헤집어 놓을 순 없다.  

마틴 파울러의 몇 가지 조언들
1. 리팩터링과 기능 추가를 동시에 하지말라.
2. 리팩터링을 시작하기 전에 든든한 테스트가 있는지 확인하라. 할 수 있는 한 자주 테스트를 돌려봐라. 무엇을 바꿨을 때 변화가 생겼는지 바로 알 수 있다.
3. 단계를 작게 나누어 신중하게 작업하라. 클래스의 필드 하나를 다른 클래스로 옮기기, 메서드 하나 쪼개기, 변수명 하나 바꾸기 같은 작은 단위로 작업해야 한다.

IDE를 잘 활용하여 쉽게 리팩토링을 진행하자.

결국 탄탄한 회귀 테스트를 진행해야 안전한 리팩터링을 할 수 있다.  

리팩터링만으로는 부족해서 결국 외부에서 보이는 동작이나 API를 바꿔야 한다면, 일부러 빌드를 깨뜨려 보는 것이 유용할 수도 있다.  
리팩터링 대상에 의존하는 옛날 코드들은 컴파일이 안되게 만드는 것이다. ?먼 말인지 모르겠음  

---
#### Topic 41. 테스트로 코딩하기기

"테스트는 버그를 찾기 위한 것이 아니다."

테스트의 주요한 이득이 테스트를 실행할 때가 아니라 테스트에 대해 생각하고, 테스트를 작성할 때라고 믿는다.  

**테스트에 대해 생각하기**

어떻게 테스트할지 생각만 해도 여러 문제를 떠올리고 해결할 수 있다.

**테스트가 코딩을 주도한다**

"테스트가 코드의 첫 번째 사용자다."

다른 코드와 긴밀하게 연결된 함수나 메서드는 테스트하기 힘들다.  
테스트를 실행하기 전에 온갖 환경구성을 한참 해야 하기 때문이다.  
즉, 무언가를 테스트하기 좋게 만들면 결합도도 낮아진다.  

**테스트 주도 개발**

테스트를 먼저 생각하는 것의 이점 때문에 테스트코드를 먼저 작성하자는 사람들도 있다.  
이것을 TDD(Test Driven Development)라고 부른다.  

TDD의 기본 주기
1. 추가하고 싶은 작은 기능 하나를 결정
2. 그 기능이 구현되었을 때 통과하게 될 테스트를 하나 작성
3. 테스트 실행. 다른 테스트는 통과하고 방금 추가한 테스트만 실패해야 한다.
4. 실패하는 테스트를 통과시킬 수 있는 최소한의 코드만 작성. 그리고 모든 테스트가 통과하는지 확인
5. 코드 리팩터링 시작. 개선시키면서 지속적으로 테스트 확인

TDD의 발상은 이 핵심 주기가 몇 분 정도로 매우 짧아야 한다는 것이다.  

하지만 테스트의 노예가 되는 경우도 있다.  

- 늘 테스트 커버리지 100%를 달성하기 위해 과도하게 많은 시간을 투자한다.
- 많은 수의 중복 테스트가 생긴다.
- 밑에서부터 시작하여 위로 올라가는 방식으로 설계를 한다.

TDD 실천은 좋지만 테스트 통과에 빠져 쓸모 없는 테스트 코드만 작성하게 될 수 있으니 가끔씩 큰 그림을 확인해라.
(포프TV의 포프는 실제 운영을 하면서 자주 사용하는 기능이나 복잡한 기능에서만 테스트코드를 작성하라고 제안했음. 단순 컨트롤러 같은 기능은 테스트 코드를 작성하는 시간 대비 효율이 없음)

