일단 코딩에 들어가면 대부분 기계적인 작업, 즉 설계 내용을 컴퓨터가 실행할 수 있는 문장으로 바꾸는 일만 하면 된다고들 많이 생각한다.(SI 작업 방식)  
이런 태도가 소프트웨어 프로젝트가 실패하는 가장 큰 원인이다.  
이런 태도 때문에 많은 시스템이 결국 너저분해지고, 비효율적이 되고, 구조가 망가지고, 유지 보수가 힘들어지고, 망가지게 된다.  

코딩은 기계적인 작업이 아니다. 그랬다면 1980년대 초반에 수많은 사람이 기대를 걸었던 CASE 도구들이 이미 오래전에 프로그래머를 대체했을 것이다.  
코딩할 때는 매 순간 결정을 내려야 하는데, 프로그램이 정확하게 생산적으로 작동하면서 천수를 누리도록 하려면 사려 깊은 생각과 판단으로 결정을 내려야 한다.  

#### Topic 37. 파충류의 뇌에 귀 기울이기

우리가 본능적으로 느껴지는 느낌에 귀 기울여서 왜 그런 느낌이 드는지 알아내야 한다. 그런 본능에서 불안하고 초조하고 감당하기 어려운 일 처럼 느껴지는 부분들이 있다.  

**백지의 공포**

누구나 텅 빈 화면을 두려워 한다.  
새로운 프로젝트를 시작하는 일도 두렵기는 마찬가지다.  
이미 있는 프로젝트에 새로운 모듈을 추가하는 일도 그렇다.  
많은 사람이 일을 시작하는 첫 발짝을 미루고 싶어 한다.  

이 문제의 두 가지 원인
1. 파충류의 뇌가 여러분에게 무언가 할 말이 있어서다. 의심이 생겨서다.
2. 실수할까봐 두려운 것일 수 있다.

**자신과 싸우기**

가끔은 코드가 잘 써지고, 가끔은 굉장히 힘들게 느껴진다.  
힘들게 느껴지는 이유는 아마 무의식적으로 잘못된 길을 가고 있어서 일 수 있다.  

**파충류와 이야기하는 법**

결국 본인의 무의식에 귀 기울여야 한다.

하던 일에 매몰되지 말고 그런 느낌이 오면 멈춰서 생각해봐라.  
뇌가 정리할 시간과 공간을 주자.  
코드에 대해 생각하지 말고 머리를 비운 채로 할 수 있는 일을 하라.  
산책, 수다, 잠 등 천천히 생각하자.  

이 방법이 잘 안되면 문제를 표면으로 끄집어내 보라.  
작성하는 코드에 대한 그림을 그려보기도 하고, 동료에게 설명도 하고, 프로그래머가 아닌 사람에게도 설명하고, 이런 과정을 통해 문득 깨닫게 될 수 있다.  

이래도 안되면 이제 행동해야 할 시간이다. 프로토타이핑을 만들자!

프로토타이핑 실천법
1. 포스트잇에 "프로토타이핑 중"이라고 써서 모니터 옆에 붙여라.
2. 프로토타이핑은 원래 실패한다고 자신에게 상기시켜라. 실패하지 않더라도 프로토타입은 버리는 것이라는 점도 함께 상기시켜라. 프로토타이핑으로 손해볼 일은 없다.
3. 텅 빈 에디터 화면에 여러분이 배우고 싶은 것 혹은 하고 싶은 것을 한 문장의 주석으로 표현해 보라.
4. 코딩을 시작하라.

꺼림칙했던 느낌이 코딩 도중에 갑자기 명확한 문제로 구체화 되면 즉각 해결하라.  

실험을 끝마쳤는데도 여전히 불안한 마음이 들면 다시 처음부터 시작하라.  
첫 단계는 산책과 수다, 그리고 휴식이다.  

**'여러분'의 코드뿐이 아니다.**

우리 일의 상당 부분은 기존 코드를 다루는 것이다.  
사람들은 저마다 다른 본능을 가지고 있으므로 여러분과는 다른 결정들을 내렸을 것이다.  

**코드뿐이 아니다**

직감에 귀 기울이는 방법은 계속 갈고닦아야 할 중요한 기술이다.  
그런데 이 기술은 더 많은 일에 적용할 수 있다.  
설계나 요구사항이 불편하게 느껴질 수도 있다.  
그 느낌을 분석하라.  

---
#### Topic 38. 우연에 맡기는 프로그래밍

우연한 성공에 의존하는 프로그래밍을 하지 않아야 한다. 대신 '의도적으로 프로그래밍'해야 한다.

코딩을 하면서 왜 잘 돌아가는지 모르고 코드를 계속해서 덧붙이면서 코딩을 하면 갑자기 프로그램이 돌아가지 않을 때 왜 그런지 모른다.  
왜 코드가 망가졌는지 모르는 이유는 **애초에 코드가 왜 잘 돌아가는지도 몰랐기 때문이다.**

**구현에서 생기는 우연**

단순히 코드가 지금 작성된 방식이 그렇기 때문에 생기는 우연한 일들이 있다.  
이런 우연에 기대다 보면 결국 문서화되지 않은 에러나 예외적인 경우의 동작에 의존하게 되고 만다.  

예를 들어 어떤 루틴을 잘못된 데이터를 가지고 호출했다고 보자.  
루틴은 예상하지 못한 데이터에 특정한 방식으로 반응을 하고, 여러분은 그 반응을 기반으로 코드를 작성한다.  
하지만 루틴을 만든 사람의 의도는 그 루틴이 그런 식으로 작동하는 것이 아니었다.  
만든 사람이 생각조차 못했던 경우인 것이다.  
이 루틴을 '고치면' 여러분의 코드는 작동을 멈출지도 모른다.  

가장 극단적인 경우는 여러분이 호출한 루틴이 실제로는 그렇게 설계된 루틴이 아닌데도 여러분이 원하는 효과를 내는 것처럼 보일 수 있다.  
잘못된 순서로 호출하거나, 잘못된 맥락에서 호출하는 것도 이와 관련한 문제다.  

프레드가 GUI 렌더링 프레임워크를 사용하여 화면에 무엇인가 출력하기 위해 필사적으로 노력했던 흔적을 보자.  

```
paint();
invalidate();
validate();
revalidate();
repaint();
paintImmediately();
```

하지만 여기 나온 루틴들은 결코 이런 식으로 호출하도록 설계되지 않았으므로 지금은 작동하는 것처럼 보여도 그것은 단지 우연일 뿐이다.  

상처에 소금을 뿌리는 격으로 마침내 화면이 그려지더라도 프레드는 코드로 돌아가 불필요한 호출을 제거하지 않는다.

**"이제 돌아는 가니까, 그대로 놔두는 편이 더 나을 거야..."(굉장히 자주 일어나는 상황이라 조심해야 함)**

잘 작동하는 데 괜히 건드려서 일을 만들 필요가 있을까싶다.

- 정말로 제대로 돌아가는 게 아닐지도 모른다. 그저 돌아가는 듯이 보이는 것일 수도 있다.
- 여러분이 의존하는 조건이 우연일 수 있다.
- 문서화되지 않은 동작은 라이브러리의 다음 릴리스에서 변경될 수도 있다.
- 불필요한 추가 호출은 코드를 더 느리게 만든다.
- 추가로 호출한 루틴에 새로운 버그가 생길 수도 있다.

다른 사람이 호출할 코드를 작성하고 있다면 모듈화를 잘하는 것, 그리고 잘 문서화한 적은 수의 인터페이스 아래에 구현을 숨기는 것 같은 기본 원칙들이 모두 도움이 된다.  
다른 루틴을 호출할 때도 문서화된 동작에만 의존하라. 어떤 이유로든 그럴 수 없다면 추측을 문서로 상세히 남겨라.  

우리는 생각보다 많은 우연에 의존하고 있다.  
구현하는 프로그램이 디렉터리에 쓸 수 있다는 것에 의존하고 있지 않은가?  
어떤 환경 변수나 설정 파일이 존재한다는 것은?  
서버의 시간이 정확하다는 것은?  
인터넷 검색으로 찾은 첫 번째 답에서 코드를 복사해 올 때 여러분과 동일한 상황이라고 확신하는가? 아니면 그냥 따라하는 '화물숭배'코드를 만들고 있나?  

잘 되는 듯한 답을 찾는 것과 올바른 답을 찾는 것은 다르다.  

우연은 여러 단계에서 우리를 오도할 수 있다.  
요구 사항을 만들어내는 단계부터 테스팅에 이르기까지 이 모든 단계에서 우연이 발생한다.  
테스트가 특히 가짜 원인과 우연한 결과로 가득 찬 영역이다.  
X의 원인은 Y라고 가정하기는 쉽다. 하지만 가정하지 말고 증명하라.  

모든 차원에서 사람들은 마음속에 많은 가정을 품고 작업한다.  
하지만 이런 가정을 문서화하는 경우는 드물며 개발자마다 가정이 다를 때도 많다.  
확고한 사실에 근거하지 않은 가정은 어떤 프로젝트에서든 재앙의 근원이 된다.  

**의도적으로 프로그래밍하기**

- 지금 무엇을 하고 있는지 알아야 한다.
- 경험이 적은 동료에게 코드를 상세히 설명할 수 있는가?
- 자신도 잘 모르는 코드를 만들지 마라. 왜 동작하는지 모르면 왜 실패하는지도 알리가 없다.
- 계획을 세우고 그것을 바탕으로 진행하라.
- 신뢰할 수 있는 것에만 기대라. 가정에 의존하지 말라. 무언가를 신뢰할 수 있을지 판단하기 어렵다면 일단 최악의 상황을 가정하라.
- 가정을 기록으로 남겨라.
- 코드뿐 아니라 여러분이 세운 가정도 테스트해 보아야 한다.
- 노력을 기울일 대상의 우선순위를 정하라. 중요한 것에 먼저 시간투자하라. 중요한 부분이 가장 어려운 부분이기도 한다.
- 과거의 노예가 되지 마라. 기존 코드가 앞으로 짤 코드를 지배하도록 놓아두지 말라. 더는 적절한 코드가 아니다 싶으면 어떤 코드라도 교체할 수 있다.

(연습문제)
외부에서 들어오는 데이터에 키-값 쌍을 표현하는 튜플 배열이 들어 있다고 해 보자. 이 중 DepositAccount 키에는 계좌 번호 문자열이 값으로 들어 있어야 한다.

```
[
  ...
  {:DepositAccount, "564-904-143-00" }
  ...
]
```

개발자의 쿼드 코어 노트북과 12코어 빌드 장비에서도 잘 동작했다.  
그런데 컨테이너에서 돌아가는 실제 서비스 서버에서는 자꾸 잘못된 계좌 번호가 들어온다. 무슨 일일까?

(예상답)
이걸 어케 맞춤? 코어 개수는 왜 얘기한 거지? 


(연습문제)
여러분은 음성 알림 시스템용 자동 전화 발신 장치를 만들고 있다. 그래서 연락처 데이터베이스를 관리해야 한다.  
국제전기통신엽합에서는 전화번호가 15자리 이내여야 한다고 규정하고 있고, 여러분은 전화번호를 15자리까지 저장할 수 있는 숫자 필드에 저장하기로 했다.  
여러분은 북아메리카 전체에 걸쳐 철저하게 테스트를 마쳤고 모든 것이 괜찮아 보였다.  
그런데 갑자기 지구 반대편에서 항의가 들어온다. 왜일까?  

(예상답)
전화번호가 더 긴 나라도 존재하기 때문에 데이터베이스에 전화번호가 일부 잘려서 등록되거나 등록되지 않는 오류가 발생했을 것이다.

(연습문제)  
여러분은 가정용 조리법을 5,000석 규모의 크루즈선 레스토랑용 조리법으로 변환하는 프로그램을 만들었다. 하지만 변환이 정확하지 않다고 항의를 받고 있다.  
확인해 보았지만, 코드는 16컵 1갤런이라는 공식을 쓰고 있다. 정확하다. 아닌가?  

(예상답)
나라마다 사용하는 단위가 달라서 문제의 소지가 있다.

---
#### Topic 39. 알고리즘의 속도

알고리즘 속도의 질문에 대합 답에는 상식과 분석, O표기법의 근삿값을 기록하는 방식을 이용한다.  

**대문자 O 표기법**  

O가 '...차수로(order of)'를 뜻함.  
O(n^2) = 원소 수가 2배로 늘어나면 시간은 4배가 된다는 의미  

n이 커질수록 가장 큰 차수에 비하면 다른 차수는 무시해도 될 정도이기 때문에, 관습적으로 최상위 차수를 제외한 다른 모든 차수는 제거하며, 상수인 계수도 표기하지 않는다.

O(n^2/2 + 3n)은 3n인 1차수를 제외하여 O(n^2/2)와 같고, O(n^2)과도 같다.  

시간복잡도 뿐만 아니라 메모리 사용량 모델링에도 유용하다.  
O(1)  -  상수 (배열의 원소 접근, 단순 명령문)
O(lgn)  - 로그 (이진 검색) 로그의 밑은 중요치 않음
O(n)  - 선형 (순차검색)
O(nlgn)  - 성형보단 좋지 않지만, 그래도 나쁘지 않음(퀵정렬과 힙정렬의 평균 수행 시간)
O(n^2)  - 제곱 (선택 정렬과 삽입 정렬)
O(n^3) - 세제곱
O(C^n)  - 지수 (여행하는 외판원 문제, 집합 분할 문제)

**상식으로 추정하기**

상식을 이용해서 간단한 알고리즘들의 차수를 대부분 추정할 수 있다.  

- 단순 반복문 : O(n), 소진 탐색, 배열에서 최댓값 찾기, 체크섬 생성하기 등.
- 중첩 반복문 : O(n^2), 버블 정렬등 이중 for문 로직.
- 반씩 자르기 : O(lgn), 이진검색, 이진 트리 탐색 등.
- 분할 정복 : O(nlgn), 퀵 정렬, 데이터를 반으로 나누고 각 반쪽에서 재귀적으로 정렬을 수행한다.
- 조합적 : 순열 관련 로직은 겁나 느림. 원소가 늘어남에 따라 계승이 따라오면서 원소 증가 횟수가 확 늘어남.

**실전에서의 알고리즘 속도**

회사에서는 보통 정렬 루틴을 작성하기 보단 이미 있는 라이브러리의 함수를 사용한다.  
하지만 앞선 기본적인 알고리즘들이 계속해서 나타난다.  
단순 반복문을 작성할 때 O(n)인 것을 알고, 그 안에 반복문이 들어오면 O(n^2)인 걸 안다.  
입력값으로 얼마나 큰 숫자가 들어올지 스스로 물어봐서 입력될 최대값을 확인하여 어느 정도 시간이 걸릴지 확인해봐야 한다.  
커다란 수가 들어왔을 때, 수행시간이나 메모리 소모에 어떤 영향을 미칠지 생각해 보는 것이 좋다.  

잠재적인 문제점을 해결하기 위해 생각해 볼 방법들  
- O(n^2) 알고리즘이 있다면 분할 정복을 사용하여 O(nlgn)으로 줄일 수 없는지 확인하자.
- 코드의 실행시간이 얼마나 될지 또는 메모리를 얼마나 사용할지 모르겠다면 직접 해봐라. 작업 시간에 영향을 주는 변수들을 변경하면서 실행해보고 그래프를 그려서 확인해봐라. (직접적인 O() 파악)
- 어떤 일을 하는 코드인지 코드 자체에 대해서도 생각해봐라. 입력 값이 작을 경우, 단순한 O(n^2)이 복잡한 O(nlgn)보다 좋을 수 있다.
- 이론적인 부분과 실무적인 부분을 모두 파악해봐라. 실제 데이터로 파악해야 정확한 결과를 알 수 있다.(실제 입력값을 기준으로 단위 테스트 결과 확인)

**적당한 알고리즘 선택시 실용적이어야 한다**

가장 빠른 알고리즘이 가장 좋은 알고리즘은 아니다.  
'성급한 최적화'를 조심하라.  
언제나 어떤 알고리즘을 개선하느라 시간을 쏟기 전에 정말로 그것이 병목인지 확인해라.  


(연습문제)  
"상식으로 추정하기"에서 "반씩 자르기"가 O(lgn)이라고 했다. 증명할 수 있는가?  

(연습문제)  
"다양한 알고리즘의 수행시간"에서 우리는 O(lgn)이 O(log10n)과 동일하고 사실 로그의 밑이 무엇이든 모두 동일하다고 했다. 왜 그런지 설명할 수 있는가?  

---
#### Topic 40. 리팩터링

코드는 정적인 존재가 아니다. 시간에 따라 발전해야 한다.  

**리팩터링이란?** 동작은 유지한 채 내부 구조를 변경하여 코드를 재구성하는 기법.

1. 체계적이다.
2. 밖으로 드러나는 동작은 바뀌지 않는다. 기능을 추가하는 작업이 아니다.

리팩터링을 일상처럼 조금씩 일정하게 수행해야 한다. 한 번에 구조를 갈아엎는 것은 안된다.  
밖으로 드러나는 동작이 바뀌지 않는다는 것을 보장하기 위해 코드 동작을 검증하는 자동화된 단위 테스트가 필요하다.

**리팩터링은 언제 하는가?**

나의 지식이 더 늘어났을 때, 현재 코드가 더 이상 적합하지 않을 때, 뭔가 잘못됐다라는 생각이 들 때 등등
- 중복 - DRY 원칙 위배
- 직교적이지 않은 설계 - 더 직교적으로 바꿀 수 있는 무언가를 발견
- 더 이상 유효하지 않은 지식 - 코드가 지금 상황에 뒤떨어지지 않도록 개선
- 사용 사례 - 실제 시스템 사용을 보면 설계시 생각했던 것과 달리 기능들의 중요도가 바뀔 수 있다.
- 성능 - 성능을 개선하려면 시스템의 한 영역에서 다른 영역으로 기능을 옮겨야 한다. ??
- 테스트 통과 - 코드를 추가한 후 추가한 테스트가 통과했을 때, 방금 추가한 코드를 바로 깔끔하게 정리해라.

**현실 세계의 복잡한 문제들**

일정의 압박 때문에 리팩터링을 하지 않게 되는 경우가 많다.  
하지만 추후 의존성이 더 커졌을 때 리팩터링을 하게 되면 시간이 더 오래 걸린다.  
그리고 그때에도 시간은 여전히 부족할 것이다.  

"일찍 리팩터링 하고, 자주 리팩터링 하자"

**리팩터링은 어떻게 하는가?**

리팩터링의 본질은 재설계다.  
여러 가지 이유로 시간이 지나면서 이전에 설계했던 모든 것들이 재설계 대상이 될 수 있다.  
하지만 그렇다고 거대한 규모의 코드를 닥치는 대로 헤집어 놓을 순 없다.  

마틴 파울러의 몇 가지 조언들
1. 리팩터링과 기능 추가를 동시에 하지말라.
2. 리팩터링을 시작하기 전에 든든한 테스트가 있는지 확인하라. 할 수 있는 한 자주 테스트를 돌려봐라. 무엇을 바꿨을 때 변화가 생겼는지 바로 알 수 있다.
3. 단계를 작게 나누어 신중하게 작업하라. 클래스의 필드 하나를 다른 클래스로 옮기기, 메서드 하나 쪼개기, 변수명 하나 바꾸기 같은 작은 단위로 작업해야 한다.

IDE를 잘 활용하여 쉽게 리팩토링을 진행하자.

결국 탄탄한 회귀 테스트를 진행해야 안전한 리팩터링을 할 수 있다.  

리팩터링만으로는 부족해서 결국 외부에서 보이는 동작이나 API를 바꿔야 한다면, 일부러 빌드를 깨뜨려 보는 것이 유용할 수도 있다.  
리팩터링 대상에 의존하는 옛날 코드들은 컴파일이 안되게 만드는 것이다. ?먼 말인지 모르겠음  

---
#### Topic 41. 테스트로 코딩하기기

"테스트는 버그를 찾기 위한 것이 아니다."

테스트의 주요한 이득이 테스트를 실행할 때가 아니라 테스트에 대해 생각하고, 테스트를 작성할 때라고 믿는다.  

**테스트에 대해 생각하기**

어떻게 테스트할지 생각만 해도 여러 문제를 떠올리고 해결할 수 있다.

**테스트가 코딩을 주도한다**

"테스트가 코드의 첫 번째 사용자다."

다른 코드와 긴밀하게 연결된 함수나 메서드는 테스트하기 힘들다.  
테스트를 실행하기 전에 온갖 환경구성을 한참 해야 하기 때문이다.  
즉, 무언가를 테스트하기 좋게 만들면 결합도도 낮아진다.  

**테스트 주도 개발**

테스트를 먼저 생각하는 것의 이점 때문에 테스트코드를 먼저 작성하자는 사람들도 있다.  
이것을 TDD(Test Driven Development)라고 부른다.  

TDD의 기본 주기
1. 추가하고 싶은 작은 기능 하나를 결정
2. 그 기능이 구현되었을 때 통과하게 될 테스트를 하나 작성
3. 테스트 실행. 다른 테스트는 통과하고 방금 추가한 테스트만 실패해야 한다.
4. 실패하는 테스트를 통과시킬 수 있는 최소한의 코드만 작성. 그리고 모든 테스트가 통과하는지 확인
5. 코드 리팩터링 시작. 개선시키면서 지속적으로 테스트 확인

TDD의 발상은 이 핵심 주기가 몇 분 정도로 매우 짧아야 한다는 것이다.  

하지만 테스트의 노예가 되는 경우도 있다.  

- 늘 테스트 커버리지 100%를 달성하기 위해 과도하게 많은 시간을 투자한다.
- 많은 수의 중복 테스트가 생긴다.
- 밑에서부터 시작하여 위로 올라가는 방식으로 설계를 한다.

TDD 실천은 좋지만 테스트 통과에 빠져 쓸모 없는 테스트 코드만 작성하게 될 수 있으니 가끔씩 큰 그림을 확인해라.
(포프TV의 포프는 실제 운영을 하면서 자주 사용하는 기능이나 복잡한 기능에서만 테스트코드를 작성하라고 제안했음. 단순 컨트롤러 같은 기능은 테스트 코드를 작성하는 시간 대비 효율이 없음)

>상향식 vs 하향식  
>둘 다 정답이 아니다. 그냥 점진적으로 끝에서 끝까지 만들어라.
>그냥 애자일 방식처럼 요구사항을 구체화하면서 완성시켜라.  

**단위 테스트**

모듈을 통제된 (심지어 인위적으로 만들어진) 환경에서 테스트하고 나면 외부에서 활용될 때 어떻게 사용될지 더 잘 안다.  
일반적으로 SW단위 테스트는 일종의 인위적인 환경을 구축한 다음, 테스트할 모듈의 루틴을 호출한다.  
그런 다음 반환된 결과들을 이미 알고있는 값과 비교해 보거나 똑같은 테스트를 이전에 돌렸을 때 나온 값과 비교하여 올바른지 검사한다.  
동일한 테스트를 코드 수정 후 다시 돌려보는 것을 회귀 테스트라고 한다.  
어떻게 단위 테스트를 할지 알아보자.  

**계약을 지키는지 테스트하기**

단위 테스트는 계약을 잘 지키는지 보는 테스트라고 여긴다.  
이런 테스트를 통해 두 가지를 알 수 있다.  
1. 코드가 계약을 지키는지 여부
2. 코드로 표현된 계약의 의미가 우리가 생각한 것과 일치하는지 여부

우리는 다양한 종류의 테스트 케이스와 경계조건에서도 모듈이 약속한 대로 기능을 잘 수행하는지 테스트하고 싶다.  
그런 실전에서는 어떻게 해야 할까?  

예제) 제곱근을 구하는 루틴에 대한 계약 내용
```
pre-conditions : argument >= 0;

post-conditions : ((result * result) - argument).abs <= epsilon * argument;
```

여기서 우리는 무엇을 테스트해야 하는지 알 수 있다.  
- 음수를 인자로 주고 거부되는지 확인
- 경곗값인 0을 인자로 주고 받아들이는지 확인
- 0과 표현할 수 있는 최댓값 사이의 값을 인자로 주고, 반환된 값을 다시 제곱한 값과 입력값 사이의 오차 비율이 특정한 작은 값인 엡실론 이하인지 확인

이런 계약이 갖추어져 있고 우리 루틴이 선행 조건과 후행 조건을 스스로 점검할 수 있다면, 우리는 제곱근 함수에게 이것저것 시켜 보는 간단한 테스트 스크립트를 작성하기만 하면 된다.  
그런 다음에는 이 스크립트를 실행시켜서 우리의 제곱근 함수를 테스트한다.  

```
assertWithinEpsilon(my_sqrt(0),0)
assertWithinEpsilon(my_sqrt(2.0),1.4142135624)
assertWithinEpsilon(my_sqrt(64.0),8.0)
assertWithinEpsilon(my_sqrt(1.0e7),3162.277602)
assertRaiseException fn => my_sqrt(-4.0) end
```

현실에선 아주 사소한 모듈이 아닌 이상 여러 개의 다른 모듈에 의존했을 가능성이 있다.  

어떻게 이런 모듈들을 조합하여 테스트할 수 있나?  

A라는 모듈이 DataFeed와 LinearRegression이라는 모듈을 사용한다고 가정하자.  
다음과 같은 순서로 테스트를 진행할 것이다.  
1. DataFeed의 계약을 완전히 테스트한다.
2. LinearRegression의 계약을 완전히 테스트한다.
3. A의 계약을 테스트한다. A의 계약은 나머지 모듈의 계약에 의존하지만 그 사실이 직접적으로 드러나진 않는다.

위는 어떤 모듈이 있을 때 의존하는 하위 모듈들을 테스트하는 방식이다.  
하위 모듈들을 모두 테스트해야 해당 모듈을 테스트할 수 있다.  
이런 것을 통해 문제의 근원을 명확히 알 수 있다.  
하위 모듈들이 모두 테스트 통과 후 해당 모듈이 통과하지 못한다면 해당 모듈의 내부 구조나 하위 모듈들을 사용하는 방법에 문제가 있을 것이다.  

**임시테스트**

우리가 코드를 이리저리 찔러 보는 것이다.  
console.log()를 통해 확인하는 것도 있을 수 있고, 디버거나 IDE환경, REPL에 직접 실행하면서 입력하는 코드 조각일 수도 있다.  
디버깅 작업이 끝나면 이런 임시 테스트를 정식 테스트의 형태로 만들어 두어야 한다.  
한 번 잘못된 코드라면 다시 잘못될 가능성이 높다.  
여러분이 만든 테스트를 그냥 버리지 말고 기존의 단위 테스트 군단에 합류시켜라.  

**테스트 접점 만들기**

아무리 테스트를 잘 갖추어도 버그는 발생할 수 있다.  
소프트웨어를 배포한 후에도 테스트할 일이 자주 발생한다.  
어떤 모듈의 내부 상태를 디버거 없이 다양한 형태로 볼 수 있는 방법을 제공할 수도 있다.  
(디버거는 이미 출시된 애플리케이션에서는 사용이 불편하거나 아예 불가능할 수도 있다.)  

로그 파일에 쌓이는 추적(trace)메시지가 이런 메커니즘 가운데 하나다.  
로그 메시지는 반드시 일관적이고 규칙적이어야 한다.  
프로그램의 처리 시간이나 논리 경로를 추적하기 위해 로그를 자동 파싱하고 싶은 경우가 있기 때문이다.  

또 다른 메커니즘으론 '단축키'조합이나 숨겨진 URL방식이 있다.  
어떤 특정한 키 조합을 누르거나 특정 URL로 들어가면 상태 정보와 그 외의 것들이 들어 있는 진단 제어창이 열리게 만드는 것이다.  

더 일반적으로는 '기능 스위치'(특정 기능 활성/비활성)를 사용하여 특정 사용자나 사용자 집단에 대해 진단 메시지를 더 많이 남기도록 할 수 있다.  

**테스트 문화**

모든 SW는 언젠간 테스트된다. 내부적으로 하지 않으면 결국 사용자가 테스트하게 된다.  
그러니 철저하게 테스트 계획을 세우는 것이 좋다.  

테스트에 대한 선택지
- 테스트 먼저
- 코드와 테스트를 함께
- 테스트하지 않음

"테스트 먼저"가 대부분 상황에서 최상의 선택일 것이다.  
나중에 테스트는 헛소리다 결국 테스트하지 않는다.  

제대로 된 테스트 문화를 가졌다면, 모든 테스트가 언제나 통과해야 한다.  
"언제나 실패"하는 불량 테스트를 무시하다 보면 모든 테스트를 무시하게 된다.  

테스트 코드를 다른 제품 코드와 마찬가지로 다뤄라.  
결합도를 낮추고, 깨끗하고 견고하게 유지하라.  
GUI 시스템의 위젯 위치나 서버 로그에 찍힌 현재 시간, 에러 메시지의 문구처럼 신뢰할 수 없는 것에 의존하지 말라.  

테스트는 프로그래밍의 일부다.  
테스트, 설계, 코딩, 이 모든 것이 프로그래밍이다.  

>저자의 경험을 기준으로 보면 테스트 코드를 항상 작성해왔는데, 너무 TDD를 너무 맹신하는 집단 때문에 테스트코드를 작성하지 않고 진행해봤다.
>근데 큰 차이가 없이 테스트하기 좋은 코드를 이미 작성하고 있었다.
>이미 오랫동안 테스트 코드를 작성해왔기 때문에 사고 방향이 충분히 TDD에 맞는 코드를 구현하는 것이다.
>하지만 본인이 테스트 경력이 얼마 안된다면 테스트를 해보는 것을 추천한다.

내 생각엔 모든 것을 테스트할 필욘 없다고 생각한다.  
충분히 테스트할 가치가 있는 코드는 정해져 있을 것이다.  

---
#### Topic 42. 속성 기반 테스트

"믿으라, 하지만 확인하라" -러시아 속담-  

우리는 함수를 작성할 때 단위 테스트도 작성하기를 추천한다.  
단위테스트 작성을 위해 우리의 지식을 바탕으로 일반적으로 문제가 될 만한 상황들을 떠올린다.  

하지만 이렇게 되면 결국 코딩하는 사람과 테스트를 작성하는 사람이 같기 때문에 문제를 문제로 인식하지 못하고 넘어가는 경우가 생기게 될 수 있다.  
따라서 이 문제를 해결하려면 코드 작성과 테스트를 다른 사람이 하는 것이다.  
하지만 테스트에 대해 생각하는 것으로 코드가 개선되는 효과를 놓치게 된다.  
그래서 더 선호하는 대안은 컴퓨터에게 테스트를 맡기는 것이다.  (?이게 먼말이여)  
컴퓨터는 여러분과 달리 선입견이 없으니까 말이다.  

**계약, 불변식, 속성**

속성 기반 테스트로 가정을 검증하라.  
속성이란 선행 조건과 후행 조건과 지켜야 하는 불변식 등을 말한다.  

리스트의 정렬 기능을 테스트해보자.  
리스트 정렬 기능의 한 가지 속성은 리스트가 정렬되어도 원소 개수는 동일하다는 불변식이 있다.  
또한 정렬된 리스트에서 모든 원소는 다음 원소보다 클 수 없다는 것도 있다.  

이제 코드로 표현해보자.  
대부분의 언어는 속성 기반 프레임워크를 갖추고 있다.  
파이썬 예에선 Hypothesis 라이브러리와 pytest를 활용하겠다.  
```python
from hypothesis import given
import hypothesis.strategies as some

@given(some.lists(some.integers()))
def test_list_size_is_invariant_across_sorting(a_list):
  original_length = len(a_list)
  a_list.sort()
  assert len(a_list) == original_length

@given(some.lists(some.text()))
def test_sorted_result_is_ordered(a_list):
  a_list.sort()
  for i in range(len(a_list) - 1):
    assert a_list[i] <= a_list[i + 1]
```
이후 테스트를 실행하면 성공한다.  
Hypothesis는 보이지 않는 곳에서 이 테스트를 백 번씩이나 돌렸다.  
매번 다른 리스트를 입력으로 넘겼다. 무작위로 만든 200개의 리스트로 200개의 테스트를 수행한 셈이다.  

**테스트 데이터 생성**

대부분의 속성 기반 테스트 라이브러리를 잘 확인하자.

**잘못된 가정 찾기**

속성 기반 테스트를 통해 가정해둔 사실이 잘못된 부분이 없는지 확인해야 한다.  

**속성 기반 테스트는 설계에 도움이 된다**

단위 테스트와 속성 기반 테스트는 서로 보완되는 부분이 있다.  
속성 기반 테스트를 통해 불변식과 계약이라는 관점으로 코드를 바라보게 한다.  

(연습문제)
여러분이 기계를 운송하는 회사에 다닌다. 기계는 하나씩 상자에 포장되어 있다. 상자는 모두 직육면체지만, 크기는 제각각이다.  
배송 트럭에 상자를 실을 때 가장 많은 상자를 싣는 방법을 찾는 코드를 작성하는 게 과제다.  
단, 상자 위에 다른 상자를 쌓지 않는다. 프로그램의 출력은 실을 상자의 목록인데, 이 목록에는 트럭 내에서 각 상자의 위치와 상자의 가로 및 세로 길이가 들어 있다.  
출력의 어떤 속성을 테스트할 수 있겠는가?  

(예상답)  
불변식으로 트럭의 면적 보다 상자의 면적의 합이 작아야 한다.  
위치가 겹치는 경우가 있는가?  
등등

---
#### Topic 43. 바깥에서는 안전에 주의하라

"좋은 울타리가 좋은 이웃을 만든다" -로버트 프로스트-  

개발자의 부주의로 많은 피해 사례가 발생한다. 따라서 우리는 지나칠 정도로 의심을 하면서 코딩해야 한다.  

**나머지 90%**

여러분은 코드를 결국 작동하도록 만들고 완성되었음을 선포한 다음 다른 문제로 넘어간다.  
하지만 그 완성되지 않았다. 90% 완성한 것이다. 그 90%에 대해서 문제가 생길 수 있는 경우를 확인해야 한다.  

**기본 보안 원칙**

1. 공격 표면을 최소화하라.  
  a. 코드의 복잡성을 줄여라  
  b. 입력 데이터 - 외부 데이터를 신뢰하지 마라. (외부 입력을 통해 명령어를 전달할 수 있다)  
  c. 인증이 없는 서비스 - 이런 서비스는 누구든지 호출할 수 있기 때문에 DoS 공격이 가능해진다. 데이터 유출도 조심하자.  
  d. 인증을 요구하는 서비스 - 인증 받은 사용자 수를 최소로 유지하자. 배포 시스템의 인증 정보를 가진 계정이 유출되면 제품 전체가 유출된 거다.
  e. 출력 데이터 - 정보를 누설하지 마라. 응답에 들어 있는 데이터가 사용자의 권한에 적절한지 늘 확인하라. 마스킹을 통해 전체가 아닌 일부만 노출하든지 해라.
  f. 디버깅 정보 - ATM 기계나 키오스크, 웹브라우저에 스택 트레이스나 데이터가 나타날 경우가 있다.
2. 최소 권한 원칙 - 최소한의 권한만을 꼭 필요한 시간만큼만 제일 짧게 부여하라. 유닉스를 예로 보면 관리자 권한으로 사용자를 만들면 다시 관리자로 이동하지 않고 바로 만든 사용자로 돌아간다. 이런 식의 시스템을 만들어서 권한을 관리하라.  
3. 안전한 기본값 - 비밀번호 표시를 *로 하는 것이 기본값인 것 처럼 안전한 기본값을 적용하자.
4. 민감 정보 암호화 - 개인 정보 등 민감한 정보는 암호화하여 저장하자. 또한 버전 관리 시스템에 암호나 API키, SSH키, 암호화 비밀번호 등 다른 인증정보를 소스코드용 버전 관리 시스템에 넣지 마라.  
5. 보안 업데이트 적용

**상식 대 암호**

우리 상식과 암호학은 맞지 않을 수가 있다. 따라서 직접 암호화 로직을 구현할 생각하지 말고, 이미 있는 걸 써라.  

---
#### Topic 44. 이름 짓기

코드에서 하는 역할에 따라 이름을 지어야한다고 믿는다. 무언가를 만들 때 마다 '이걸 왜 만들어야 하지?'를 생각해야 한다는 뜻이다.  

**문화를 존중하라**

"컴퓨터 과학에는 어려운 문제가 딱 두 개 있다. 캐시 무효화와 이름 짓기."

대부분의 컴퓨터 입문용 교재는 i, j, k 같은 한 글자 변수명을 절대 사용하지 말라고 한다.  

**일관성**

팀내에 일관성(사용하는 용어 등)을 지키도록 하려면 몇 가지 방법이 있다.  
많은 의사소통을 장려해야 한다.  
프로젝트 용어 사전을 만든다.  

**이름 바꾸기는 더 어렵다**

시간이 지나서 이름이 사용되는 의미가 바뀌면 제때 이름을 바꿔라. 

- 도전해 볼 것
  * 지나치게 일반적인 이름을 가진 함수나 메서드를 발견했다면, 실제로 하는 일을 모두 반영하도록 이름을 바꿔봐라.
  * 습관적으로 사용하는 이름 중 개선할 만한 것이 있을까?
  * 시스템에서 사용하는 이름이 해당 도메의 사용자들이 사용하는 용어와 일치하는가? 왜 그런가? 그 이름 때문에 인지 부조화가 발생하진 않는가?
  * 시스템에 있는 이름을 바꾸기 힘든가? 이 깨진 창문을 고치기 위해 어떤 일을 할 수 있는가?


