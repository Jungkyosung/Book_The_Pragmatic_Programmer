Topic8. 좋은 설계의 핵심

좋은 설계란? 바꾸기 쉬운 설계(유지보수가 쉬움. 바꾸기 쉽다는 것은 결합도가 낮다는 것)
어떻게 해야 결합도가 낮아지는가? 추후 알아보자.

Topic9. DRY(Don't Repeat Yourself): 중복의 해악

중복 요소를 제거해라.
중복 여부를 어떻게 판단할 수 있나? 코드 하나를 바꿨을 때 여러 측면을 바꾸게 된다면 중복적인 요소라고 볼 수 있다.

주의사항!) 코드의 중복이 지식의 중복은 아니다.
전달하려는 메시지가 다르다면 코드는 중복일 수 있다.

문서화 중복을 피하라. 코드를 통해 내용을 이해할 수 있도록 작성하라.(주석이 필요없도록 작성하는 게 좋겠지만 원어민 입장에서만 영어로된 함수명이 그런 부분에서 훨씬 쉽고 도움이 되겠다. 한국인으로서 만약 주석과 코드내용이 중복이더라도 주석을 적어야 원어민이 함수명을 읽는 것처럼 프로그램의 흐름을 더 빠르게 읽을 수 있다. 그러니 주석은 적당한 수준에서 내용을 이해할 수 있도록 필수라고 생각함)

개발자 간의 중복을 줄이기 위해 서로 미팅을 하면서 공통요소를 찾고 공통팀에서 관리할 수 있게 하라. 중간에서 누군가 전반적인 코드의 흐름을 보고 중복되는 부분은 공통쪽으로 나눠서 관리하도록 중개해주면 좋다.

Topic10. 직교성

직교성이란? 기하학에서 빌려온 용어로 그래프의 축과 같이 직각으로 만나는 경우 직교한다고 함.
한마디로 두 선이 관계가 없다는 소리로 결합도가 낮다는 것.
결합도가 낮으면 한쪽을 변경했을 때 다른 한쪽은 고정되어 있기 때문에 유지보수하기 편함.

툴킷과 라이브러리도 영향도를 잘 고려하여 선택하고 사용해라.

코딩시 직교성을 높이는 법
1. 코드의 결합도를 줄여라. 객체의 상태를 바꿀 필요가 있다면 객체가 직접 상태를 바꾸도록 하라.
2. 전역 데이터를 피하라. 싱글턴 사용을 주의하라.
3. 유사한 함수를 피하라. 유사한 함수를 구현할 경우 전략 패턴과 같은 도구를 사용할지 고려해봐라.

직교적으로 설계되고 구현된 시스템은 테스트에도 유리하다. 직교적으로 설계됐을수록 단위 테스트가 쉽고, 단위테스트가 쉬울 수록 통합테스트하기 쉽다. 단위 테스트 중 나머지 시스템 중 상당 부분을 불러와야 한다면 결합도가 높다는 것이다.

문서화에서도 직교성을 고려하라. 핵심 내용은 유지한 채 틀만 그때 그때 바꿀 수 있는 markdown 같은 도구가 있다.


[연습문제]
파일에서 데이터를 읽는 클래스를 만들어야 함. 한 번에 한 줄씩 읽어 들이고, 각 줄은 여러 개의 필드로 쪼개야 한다. 의사 코드로 표현한 다음 두 클래스 중 어떤 것이 더 직교적인가?

class Split1 {
  constructor(fileName)  # 읽기 위해 파일을 열기
  def readNextLine()     # 다음 줄로 이동
  def getField(n)        # 현재 줄의 n번째 필드를 반환
}

class Split2 {
  Constructor(line)  # 한 줄을 쪼개기
  def getField(n)    # 현재 줄의 n번째 필드를 반환
}

(예상답) Split2가 좀 더 순수함수에 가깝다. 들어온 인풋에 따라 아웃풋이 예상 가능하다. 
이와 달리 Split1은 constructor를 사용한 이후에 readNextLine을 사용할 때 마다 매번 다른 아웃풋을 만들어 냄. 


[연습문제2]
객체 지향 언어와 함수형 언어의 직교성은 어떻게 다를까? 이런 차이가 언어 자체에 내재된 것일까? 아니면 사람들이 언어를 사용하는 방법이 다른 것일까?

(예상답) 객체 지향 언어는 결합도를 줄이는 방식으로 객체간의 소통을 사용하고 함수형 언어는 순수함수를 사용하여 결합도를 줄인다. 각 언어를 통해 어느 정도는 사용방법이 달라 그런 차이를 유도하기도 하지만 사람들이 사용하는 기법을 언어의 철학을 따르지 않는다면 객체지향언어로 절차구조적인 방식으로 프로그래밍 할 수 있듯이 어떻게 해당 언어를 사용하냐도 중요하다고 생각함. 

Topic11. 가역성

