#### Topic8. 좋은 설계의 핵심

좋은 설계란? 바꾸기 쉬운 설계(유지보수가 쉬움. 바꾸기 쉽다는 것은 결합도가 낮다는 것)
어떻게 해야 결합도가 낮아지는가? 추후 알아보자.

#### Topic9. DRY(Don't Repeat Yourself): 중복의 해악

중복 요소를 제거해라.
중복 여부를 어떻게 판단할 수 있나? 코드 하나를 바꿨을 때 여러 측면을 바꾸게 된다면 중복적인 요소라고 볼 수 있다.

주의사항!) 코드의 중복이 지식의 중복은 아니다.
전달하려는 메시지가 다르다면 코드는 중복일 수 있다.

문서화 중복을 피하라. 코드를 통해 내용을 이해할 수 있도록 작성하라.(주석이 필요없도록 작성하는 게 좋겠지만 원어민 입장에서만 영어로된 함수명이 그런 부분에서 훨씬 쉽고 도움이 되겠다. 한국인으로서 만약 주석과 코드내용이 중복이더라도 주석을 적어야 원어민이 함수명을 읽는 것처럼 프로그램의 흐름을 더 빠르게 읽을 수 있다. 그러니 주석은 적당한 수준에서 내용을 이해할 수 있도록 필수라고 생각함)

개발자 간의 중복을 줄이기 위해 서로 미팅을 하면서 공통요소를 찾고 공통팀에서 관리할 수 있게 하라. 중간에서 누군가 전반적인 코드의 흐름을 보고 중복되는 부분은 공통쪽으로 나눠서 관리하도록 중개해주면 좋다.

#### Topic10. 직교성

직교성이란? 기하학에서 빌려온 용어로 그래프의 축과 같이 직각으로 만나는 경우 직교한다고 함.
한마디로 두 선이 관계가 없다는 소리로 결합도가 낮다는 것.
결합도가 낮으면 한쪽을 변경했을 때 다른 한쪽은 고정되어 있기 때문에 유지보수하기 편함.

툴킷과 라이브러리도 영향도를 잘 고려하여 선택하고 사용해라.

코딩시 직교성을 높이는 법
1. 코드의 결합도를 줄여라. 객체의 상태를 바꿀 필요가 있다면 객체가 직접 상태를 바꾸도록 하라.
2. 전역 데이터를 피하라. 싱글턴 사용을 주의하라.
3. 유사한 함수를 피하라. 유사한 함수를 구현할 경우 전략 패턴과 같은 도구를 사용할지 고려해봐라.

직교적으로 설계되고 구현된 시스템은 테스트에도 유리하다. 직교적으로 설계됐을수록 단위 테스트가 쉽고, 단위테스트가 쉬울 수록 통합테스트하기 쉽다. 단위 테스트 중 나머지 시스템 중 상당 부분을 불러와야 한다면 결합도가 높다는 것이다.

문서화에서도 직교성을 고려하라. 핵심 내용은 유지한 채 틀만 그때 그때 바꿀 수 있는 markdown 같은 도구가 있다.


[연습문제]
파일에서 데이터를 읽는 클래스를 만들어야 함. 한 번에 한 줄씩 읽어 들이고, 각 줄은 여러 개의 필드로 쪼개야 한다. 의사 코드로 표현한 다음 두 클래스 중 어떤 것이 더 직교적인가?

class Split1 {
  constructor(fileName)  # 읽기 위해 파일을 열기
  def readNextLine()     # 다음 줄로 이동
  def getField(n)        # 현재 줄의 n번째 필드를 반환
}

class Split2 {
  Constructor(line)  # 한 줄을 쪼개기
  def getField(n)    # 현재 줄의 n번째 필드를 반환
}

(예상답) Split2가 좀 더 순수함수에 가깝다. 들어온 인풋에 따라 아웃풋이 예상 가능하다. 
이와 달리 Split1은 constructor를 사용한 이후에 readNextLine을 사용할 때 마다 매번 다른 아웃풋을 만들어 냄. 


[연습문제2]
객체 지향 언어와 함수형 언어의 직교성은 어떻게 다를까? 이런 차이가 언어 자체에 내재된 것일까? 아니면 사람들이 언어를 사용하는 방법이 다른 것일까?

(예상답) 객체 지향 언어는 결합도를 줄이는 방식으로 객체간의 소통을 사용하고 함수형 언어는 순수함수를 사용하여 결합도를 줄인다. 각 언어를 통해 어느 정도는 사용방법이 달라 그런 차이를 유도하기도 하지만 사람들이 사용하는 기법을 언어의 철학을 따르지 않는다면 객체지향언어로 절차구조적인 방식으로 프로그래밍 할 수 있듯이 어떻게 해당 언어를 사용하냐도 중요하다고 생각함. 

#### Topic11. 가역성(거꾸로 되돌릴 수 있는 성질)

의사결정은 언제든지 바뀔 수 있다. 의사결정이 바뀐다는 가정을 하고 프로그래밍해야 한다.
그렇다면 유연한 아키텍처가 필요하다.

아키텍처는 굉장히 변덕스럽게 변하고 있다.
예시(서버측 아키텍처) : 거대한 쇳덩이 -> 큰 쇳덩이를 많이 연결한 것 -> 일반 상용 하드웨어로 만든 클러스터들로 부하를 분산시키는 것 -> 애플리케이션을 구동하는 클라우드 기반 가상 머신 -> 서비스를 구동하는 클라우드 기반 가상 머신 -> 그 가상 머신을 컨테이너화한 것 -> 클라우드 기반 서버리스 애플리케이션 -> 아니나 다를까 일부 작업에 대해서는 다시 거대한 쇳덩어리로 돌아가는 듯함

이런 환경에서 계획을 세우는 것은 불가능하다. 언제 어떻게 바뀔지 모른다. 따라서 바꾸기 쉽게 만들어라. 외부의 API를 추상화 계층 뒤로 숨겨라.

#### Topic12. 예광탄

예광탄은 결국 애자일 방법론과 유사하다. 최대한 빠르게 구현을 해보고 어느 정도 프로그램이 돌아가는지 확인하는 방법이다.  
(그렇다면 이걸 전체 프로젝트 단위가 아닌 팀단위에서도 수행할 수 있는 것인가? 그렇다면 어떻게 적용해야 할까?)

이 방법론을 통해 얻는 이점
- 사용자가 뭔가 작동하는 것을 일찍부터 보게 된다. 사용자의 두려움을 해소하고 막연한 기획 이미지를 좀 더 구체화 할 수 있음.
- 개발자가 들어가서 일할 수 있는 구조를 얻는다. 전반적인 프로그램의 계층이 파악되기 때문에 각 계층에 필요한 개발자를 투입시킬 수 있음.
- 통합 작업을 수행할 기반이 생긴다. 퍼즐을 만들어서 붙일 판이 마련됐기 때문에 단위 테스트가 끝난 코드를 붙이고 어떻게 영향을 미치는 지 확인할 수 있음.
- 보여줄 것이 생긴다. 데모 버전을 통해 안정감을 줄 수 있다.
- 진행 상황에 대해 더 정확하게 감을 잡을 수 있다. 유스케이스를 하나씩 구현하여 작업 진행도를 파악하기 쉽다.

**예광탄이 언제나 목표물을 맞히는 것은 아니다**

예광탄이 맞추는 목표가 바뀐다면 언제든지 조준을 수정해야 한다.

프로토타이핑은 나중에 버리는 코드이며, 예광탄 코드는 기능은 별로 없지만 완결된 코드이다.

#### Topic. 프로토타입과 포스트잇

프로토타이핑으로 조사할 대상은? 위험을 수반하는 모든 것(아직 잘 알지 못해서 어떤 결과를 초래할지 알고 싶은 것, 결국 결과 예측용)  
구체적 예시)
- 아키텍처
- 기존 시스템에 추가할 새로운 기능
- 외부 데이터의 구조 혹은 내용
- 외부에서 가져온 도구나 컴포넌트
- 성능 문제
- 사용자 인터페이스 설계

프로토타입은 특정 세부사항을 무시할 수도 있다. 테스트(확인) 하고 싶은 부분만 제대로 확인하면 된다.

프로토타입은 폐기할 코드라는 것을 생각하고 구현해야 한다. (단지 테스트용, 완벽하게 구현하려면 지속적인 테스트를 통한 완전체를 별도로 개발해야 함)

(연습문제)  
마케팅 부서는 여러분과 함께 웹 페이지 디자인 몇 개를 브레인스토밍하고 싶어 한다. 마케팅 부서에서 생각하는 방식은 클릭할 수 있는 이미지 맵을 만들어서 다른 페이지들을 연결하는 방식이다. 하지만 어떤 이미지를 사용할지는 아직 결정하지 못했다. 자동차 사진일 수도 있고 전화기 혹은 집일 수도 있다. 클릭하면 이동할 페이지 목록과 내용을 받았는데 마케팅팀은 프로토타입을 몇 개 보고 싶어 한다. 잠깐, 준비할 시간은 15분 밖에 없다. 여러분은 어떤 도구를 사용하겠는가? 

(예상답)
그냥 메모지에 그림을 그려서 보여줌.

#### Topic14. 도메인 언어

"언어의 한계가 곧 자기 세계의 한계다." - 루트비히 비트겐슈타인- 

(? 내부언어와 외부언어가 무슨 차이인지 모르겠음. 이 파트는 잘 이해가 가지 않음.)

(연습문제)  
간단한 터틀 그래픽 시스템을 제어하기 위해 소형 언어를 하난 구현하려 이 언어는 한 글자짜리 명령어들로 구성되는데 어떤 명령어는 뒤에 한 자리 숫자가 따라 나올 수도 있다.
예를 들어 다음 내용을 입력하면 사각형이 하나 그려진다.

P 2 # 2번 펜을 선택한다.
D   # 펜을 종이에 가져다 댄다.
W 2 # 서쪽으로 2cm 이동하며 그린다.
N 1 # 그다음 북쪽으로 1cm 이동하며 그린다.
E 2 # 그다음 동쪽으로 2cm 이동하며 그린다.
S 1 # 그다음 남쪽으로 1cm 이동하며 그린다.
U   # 펜을 종이에서 뗀다.

이 언어를 파싱하는 코드를 구현하라. 새로운 명령어를 추가하기 쉽게 코드를 설계해야 한다.

(연습문제)  
앞 문제에서 우리는 외부 도메인 언어인 그리기 언어용 파서를 구현했다. 이번에는 내부 언어로 다시 구현해 보자. 기발한 발상을 떠올릴 필요 없다. 그냥 명령어마다 함수를 만들면 된다. 어쩌면 명령어를 소문자로 바꿔야 할 수도 있고 문맥 정보를 전달하기 위하여 명령어를 무언가로 감싸야 할 수도 있다.

(연습문제)  
시간 표현을 파싱하는 BNF(배커스-나우루 표기법, Backus-Naur form)문법을 하난 설계하라. 다음의 예를 모두 파싱할 수 있어야 한다.

4pm, 7:38pm, 23:42, 3:16, 3:16am

(연습문제)  
위 연습문제의 BNF 문법을 위한 파서를 여러분이 원하는 언어의 PEG 파서 생성기를 사용하여 구현하라. 파서는 자정 이후로 몇 분이나 지났는지를 나타내는 정수를 반환하면 된다.

(연습문제)  
시간 표현 파서를 이번에는 스크립트 언어와 정규 표현식을 이용해서 구현하라.

#### Topic15. 추정

우리는 추정을 통해 문제를 어떻게 해결할지 대략 짐작할 수 있다.

추정치를 확인하기 위해 혼자 답을 하려고 노력하지말고 주위에 해당 경험을 한 사람을 찾아서 추정치를 물어보자.(이게 빠르다.)

...생략

추정치를 기록으로 남겨보고 추정치가 얼마나 정확했는지 기록으로 남겨라. 오차가 발생했다면 왜 그런지 이유를 파악해봐라.  
이런 추정치는 개발자에게 일정파악시 중요하다.

(연습문제)  
다음과 같은 질문을 받았다고 하자. "어느 쪽의 대역폭이 더 넓을까? 1Gbps네트워크 연결과 1TB 저장 장치를 주머니에 넣고 두 컴퓨터 사이를 왔다갔다하는 사람 중에서?"
여러 분의 대답이 의미가 있으려면 어떤 제약 조건을 달아야 할까? ( 예를 들어, "저장 장치에 접근하기 위해 필요한 시간은 무시한다면" 같이 조건을 달 수 있다.)

(에상답)  
사람이 저장장치를 연결하고 데이터를 옮기는 행위가 어느 정도의 시간이 걸리는가? 만약 1분이 걸린다면,
네트워크 연결시 다른 간섭 없이 온전한 1Gbps를 정확히 사용할 수 있다면,
1TB의 저장장치의 속도가 1TBbps가 나온다면

(연습문제)  
그래서 어느 쪽이 대역폭이 더 넓은가?

(예상답)  
위의 조건이 모두 맞다면 사람이 움직이는 게 빠르다. 


