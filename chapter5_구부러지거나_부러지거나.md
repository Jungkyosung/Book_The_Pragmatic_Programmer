빠른 변화 속도를 따라가려면 가능한 한 느슨하고 유연한 코드를 작성해야 한다. 그러지 않으면 코드는 금세 낡고 수정하기 어려워지고, 결국 기억 저편으로 사라진다.

되돌릴 수 있는 의사 결정을 내리는 구체적인 방법을 확인하자.

---
#### Topic28. 결합도 줄이기

"모든 것은 얽혀 있다."

결합도가 낮은 코드가 바꾸기 쉽다.

결합의 증상들
- 관계없는 모듈이나 라이브러리 간의 희한한 의존관계
- 한 모듈의 '간단한' 수정이 이와 관계없는 모듈을 통해 시스템 전역으로 퍼져 나가거나 시스템의 다른 곳에서 무언가를 깨뜨리는 경우
- 개발자가 수정하는 부분이 시스템에 어떤 영향을 미칠지 몰라 코드의 수정을 두려워하는 경우
- 변경 사항에 누가 영향을 받는지 파악하고 있는 사람이 없어서 결국 모든 사람이 참석해야 하는 회의

```
public void applyDiscount(customer, order_id, discount) {
  totals = customer
            .orders
            .find(order_id)
            .getTotals();
  totals.grandTotal = totals.grandTotal - discount;
  totals.discount = discount;
}
```

고객 객체에서 해당하는 주문 컬렉션의 참조를 얻는다. 거기서 특정한 주문을 찾고, 찾은 주문의 합계를 얻는다. 
이 합계에서 얻은 주문 총액에서 할인액을 빼고, 합계에 저장된 할인액도 갱신한다.

이 코드는 고객에서 합계까지 다섯 단계의 추상화를 오간다. 결국 최상위 코드가 모든 것을 알아야 한다.
고객 객체는 주문 컬렉션을 노출하고, 이 주문 컬렉션에는 주문 아이디를 받아서 주문 객체를 반환하는 find 메서드가 있으며, 주문 객체는 totals 객체를 가지고 있는데, 
이 totals 객체에는 총액과 할인액을 읽거나 쓸 수 있는 접근자가 있다는 것까지 다 알아야 한다.

코드를 쓰거나 이해하기 위해 알아야 하는 것이 너무 많다.  
설상가상 이 코드를 지원하기 위해 앞으로 바뀌면 안되는 것도 너무 많다.  
메서드나 속성들이 모두 연결되어 있다.  
이런 코드를 '열차 사고'라고 부른다.  

위 코드에서 책임을 져야 하는 객체에게 책임을 줘야하지만, totals 객체는 자신의 값을 제어할 수 있는 힘이 없다.  
어디서든 totals를 불러와 totals의 누구나 내부 값을 변경할 수 있다.  

"묻지 말고 말하라 (Tell, Don't Ask, TDA)"

이 원칙을 지켜야 캡슐화를 지킬 수 있다.  

캡슐화를 위한 처리
1. 할인 처리를 totals 객체에 위임
```java
public void applyDiscount(customer, order_id, discount) {
  customer
    .orders
    .find(order_id)
    .getTotals()
    .applyDiscount(discount);  //totals에 함수요청을 통해 할인을 반영(할인이 어떻게 적용되는지 외부에선 알 수 없음, 알 필요도 없음)
}
```

2. 주문 컬렉션에 위임
```java
public void applyDiscount(customer, order_id, discount) {
  customer
    .findOrder(order_id)    //order를 직접 접근하지 않고 order를 찾도록 함
    .getTotals()
    .applyDiscount(discount);
}
```

3. 주문 객체와 합계에도 적용, 주문 객체에 합계를 별도 객체에 저장했다는 사실을 알 필요가 없으니 주문 안으로 숨김
```java
public void applyDiscount(customer, order_id, discount) {
  customer
    .findOrder(order_id)
    .applyDiscount(discount);
}
```

커스터머 객체에서 주문을 찾는 요청을 호출하고 찾은 주문을 통해 할인을 적용하도록 요청한다.  
직접 수정하지 않고 각자 요청을 통했기 때문에 각 객체의 내부 내용을 각 객체가 알 필요가 없다.

책 내용의 리팩토링 순서를 따라가면 가장 꼬리부터 캡슐화를 적용했다.  
이런 리팩토링 과정을 추후 적용해보면 좋을 것 같다.  

---

#### "메서드 호출을 엮지 마라."

```java
amount = customer.orders.last().totals().amount;  //좋지 않은 예시
```

```java
//위와 같이 좋지 않은 예시
orders = customer.orders;
last = orders.last();
totals = last.totals();
amount = totals.amount;
```

엮는 것들이 절대로 바뀌지 않을 것이라면 이 규칙을 지키지 않아도 된다.  
하지만 모든 것은 바뀔 수 있다는 가정을 하고 개발을 해야 한다.  
외부 라이브러리 조차 추후 바뀔 수 있다는 가정을 해야 한다.  

언어에 포함된 라이브러리라면 꽤 안정적이라고 판단할 수 있다.
```java
people
  .sort_by {|person| person.age }
  .first(10)
  .map(| person | person.name }
```

#### "전역 데이터를 피하라."

##### 싱글턴도 전역 데이터다

외부로 노출된 인스턴스 변수가 잔뜩 있는 싱글턴은 여전히 전역 데이터다.

##### 외부 리소스도 전역 데이터다

수정 가능한 외부 리소스는 모두 전역 데이터다.  

"전역적이어야 할 만큼 중요하다면 API로 감싸라."

##### 상속은 결합을 늘린다

상속으로 다른 클래스의 상태와 행동을 그대로 가져올 수 있다.  
상속은 꼭 필요할 경우에만 사용하도록 하고 상속보단 합성을 통해 결합도를 낮추자.  

##### 결국은 모두 ETC

결합된 코드는 바꾸기 힘들다. 직접적으로 아는 것만 다루는 부끄럼쟁이 코드를 계속 유지하라. (방어운전처럼, 결국 문제를 안만들 확률이 높다.)  
그러면 애플리케이션 결합도를 낮게 유지할 수 있을 것이고, 결과적으로 코드를 바꾸기 쉬워질 것이다.(재사용 가능, 유지보수 용이, 테스트 용이)

---
#### Topic29. 실세계를 갖고 저글링하기

#### 이벤트

이벤트는 무언가 정보가 있다는 것을 의미한다.  
이벤트는 외부 또는 내부에서 발생할 수 있다.  
애플리케이션이 이런 이벤트에 반응하도록, 그리고 그에 기반해서 하는 일을 조절하도록 만들면, 진짜 세상에서 더 잘 작동하는 애플리케이션을 개발할 수 있다.  

어떻게 이벤트에 잘 반응하는 애플리케이션을 만들 수 있을까?  
1. 유한 상태 기계
2. 감시자 패턴
3. 게시-구독
4. 반응형 프로그래밍과 스트림

#### 유한 상태 기계(FSM, Finite State Machine)

##### 실용주의 FSM 해부학

상태기계는 이벤트를 어떻게 처리할지 정의한 명세일 뿐이다.  
FSM은 오로지 데이터만으로 표현할 수 있다.(표를 통해 표현 가능)

##### 행동 추가하기

리스너랑 콜백과 같이 콜백을 추가하면 좋다.

상태기계 부분을 다 읽어보니 느낀 점은 예전 책이라 단순히 이벤트 처리에 대한 내용이 별도로 들어가 있는 것 같다.
대부분의 프레임워크는 이미 이런 부분을 기본 사항으로 구현해놨기 때문에 필요할 때 이용하면 됨.(전략 패턴을 사용하는 것과 비슷하다고 느낌)

#### 감시자 패턴(observer pattern)

이벤트를 발생시키는 쪽인 '감시 대상(observable)'과 이런 이벤트에 관심이 있는 클라이언트인 '감시자'로 이루어짐.

```ruby
module Terminator
  CALLBACKS = []

  def self.register(callback)  //콜백 등록
    CALLBACKS << callback
  end

  def self.exit(exit_status)
    CALLBACKS.each { |callback| callback.(exit_status) }  
  end
end

Terminator.register(-> (status) { puts "callback 1이 #{status} 관측" })  //콜백으로 register함수(감시대상)에 내용 추가.
Terminator.register(-> (status) { puts "callback 2가 #{status} 관측" })

Terminator.exit(99)

//callback 1이 99 관측
//callback 2가 99 관측
```

감시자 패턴의 문제점 : 모든 감시자가 감시 대상에 등록을 해야 하기 때문에 결합이 생김.  
감시 대상이 콜백을 직접 호출하도록 구현하기 때문에 이 부분이 성능 병목이 될 수 있음.
(감시의 콜백을 실행하느라 감시대상 본인의 처리가 늦어짐.) 이 문제는 '게시-구독'으로 해결한다.

#### 게시(publish)-구독(subscribe), (줄여서 펍섭pubsub)

감시자 패턴을 일반화한 것. 감시자 모델의 결합도를 높이는 문제와 성능 문제도 해결

채널이라는 부분을 만들고 감시대상(게시자)은 채널에 이벤트를 보냄.  
감시자(구독자)는 관심사를 채널에 등록하여 이벤트가 채널에 들어오면 해당 이벤트를 전달 받음.

따라서 감시대상과 감시자가 직접 연결되지 않고 채널(공통 인터페이스)이라는 곳을 통해 전달 받기 때문에 결합도가 약해짐.

#### 반응형 프로그래밍과 스트림 그리고 이벤트

리액트와 뷰와 같은 데이터의 반응성을 구현할 수 있는 프레임워크가 많이 있다.  
하지만 이벤트를 이리저리 연결하는 것도 쉽지많은 않기 떄문에 '스트림'이 필요하다.  

스트림은 이벤트를 일반적인 자료구조처럼 다룰 수 있게 도와줌.  

```js
import * as Observable from 'rxjs'
import { logValues } from '../rscommon/logger.js'

let animals = Observable.of("ant", "bee", "cat", "dog", "elk")
let ticker = Observable.interval(500)

let combined = Observable.zip(animals, ticker)

combined.subscribe(next => logValues(JSON.stringify(next)))
```

위 코드는 브라우저 창의 목록에 새로운 항목을 추가하는 간단한 로깅 함수를 사용한다.  
각 항목에는 프로그램이 시작된 후부터 흐른 시간을 밀리초 단위로 붙인다.  
앞의 코드를 실행한 결과는 다음과 같다.  

500ms ["ant", 0]  
1000ms ["bee", 1]  
1500ms ["cat", 2]  
2000ms ["dog", 3]  
2500ms ["elk", 4]  

일반적으로 이벤트 스트림은 이벤트가 발생할 때마다 채워진다.  
이 말은 이벤트를 발생시키는 감시 대상들을 병렬적(먼 말임??)으로 실행시킬 수 있다는 것이다.  

```js
import * as Observable from 'rxjs'
import { mergeMap }    from 'rxjs/operators'
import { ajax }        from 'rxjs/ajax'
import { logValues }   from '../rxcommon/logger.js'

let users = Observable.of(3, 2, 1)

let result = users.pipe(mergeMap((user) => ajax.getJSON('https://reqres.in/api/users/${user}')))

result.subscribe(
  resp => logValues(JSON.stringify(resp.data)),
  err => console.error(JSON.stringify(err))
)
```

위 코드의 실행 결과는 다음과 같다.

82ms {"id" : 2, ....}  
132ms {"id" : 1, ....}  
133ms {"id" : 3, ....}  

세 개의 개별 스트림이 병렬적으로 처리되었다.  

#### 이벤트 스트림은 비동기 컬렉션

사용자가 웹사이트에 로그인 할 때 특정 정보를 수집하고 싶다면 세션이 만들어 질 때마다 사용자의 아이디를 담은 Observable을 생성해서 사용하자.  
더 이상 시간을 어떻게 관리할지 고민할 필요가 없다.  
이벤트 스트림은 동기적 처리와 비동기적 처리를 하나의 편리한 공통 API로 감싸서 통합한다.  

#### 어디에나 이벤트가 있다

이벤트를 중심으로 사용해서 코드를 구현하면 일직선으로 수행되는 코드보다 더 잘 반응하고 결합도가 더 낮다.

(연습문제)
FSM을 설명하면서 우리는 일반적인 상태 기계 구현을 자체 클래스로 분리해낼 수 있다고 언급했다. 아마 그 클래스는 상태 이행 표와 초기 상태를 넘겨서 초기화할 것이다.  
본문의 문자열 추출기를 위 클래스를 사용하여 구현해 봐라.  

(연습문제)
네 가지 전략 중에서 다음 상황에 맞는 것은 각각 어떤 것일까? 여러 전략을 조합해야 할 수도 있다.

- 5분 동안 '네트워크 인터페이스가 꺼짐' 이벤트를 세 번 받으면 운영 직원에게 알려라.
- 일몰 후에 층계 밑에서 동작이 감지된 다음 층계 위에서 동작이 감지되면 위층의 전등을 켜라.
- 다양한 보고 시스템에 주문이 완료되었음을 알리고 싶다.
- 고객에게 자동차 대출을 집행할 수 있는지 평가하기 위하여 애플리케이션이 세 가지 다른 서비스에 요청을 보내고 응답을 기다려야 한다.

(예상답)
- 리스너 콜백에 감시자 패턴이지만 조건에 따라서 처리결과가 변경되기 때문에 유한 상태 기계도 추가
- 리스너 콜백에 감시자 패턴이지만 조건에 따라서 처리결과가 변경되기 때문에 유한 상태 기계도 추가
- 주문완료를 알리고 싶다면 감시자 패턴으로 충분하나 유연하게 만들고 싶다면 게시-구독을 사용할 수 있겠다.
- 반응형 프로그래밍과 스트림을 통해 각각 요청을 보낸 후 응답을 기다려서 처리

**결국 이벤트를 사용하는 것 또한 유연해지기 위한 방법 중 하나다.**

---
#### Topic30. 변환 프로그래밍

"자신이 하고 있는 걸 하나의 과정으로 서술할 수 없다면, 자기가 뭘 하고 있는지 모르는 것이다." - W.Edwards Deming-

모든 프로그램은 데이터를 변환한다. 받은 입력을 출력으로 바꾼다. 우리는 설계를 고민할 때 변환을 만드는 것에 대해서는 거의 생각하지 않는다.  
오직 클래스와 모듈, 자료 구조, 알고리즘, 언어, 프레임워크에 대해서만 걱정할 뿐이다.  

이렇게 코드에만 집중하면 핵심을 놓칠 수 있다. 프로그램이란 입력을 출력으로 바꾸는 것이다.  

만약 1970년대로 가서 그 시절 유닉스 프로그래머에게 디렉터리 안에 있는 파일 중에 가장 긴 파일 다섯 개를 찾는 프로그램을 작성해 달라고 부탁한다면??  
(가장 길다는 것은 줄 수가 가장 많다는 뜻)  

우린 프로그래머가 에디터를 열고 C 코드를 쓸 것이라 예상할 수도 있지만, 그 당시 프로그래머는 우리가 가지고 있는 것(디렉터리 이름)과 우리가 원하는 것(긴 파일 목록)이라는 관점으로 생각하기 때문에 그냥 터미널을 열고 다음과 같이 입력할 것이다.

```
$ find . -type f | xargs wc -l | sort -n | tail -6 | head -5
```

"프로그래밍은 코드에 관한 것이지만, 프로그램은 데이터에 관한 것이다."

요구사항에서 입력과 출력을 찾고 그것을 단계별로 쪼개서 하향식으로 접근하는 것도 방법이다.

#### 변환은 프로그래밍을 변환한다

코드를 일련의 (중첩된) 변환으로 생각하는 접근 방식은 프로그래밍을 해방시킨다. 익숙해지는 데는 시간이 좀 걸리지만, 일단 습관을 들이면 여러분의 코드가 더 명확해지고, 함수는 짧아지며, 설계는 단순해질 것이다.

(연습문제)  
다음 요구 사항들을 하나의 최상위 변환으로 표현해 보자. 각 변환별로 입력과 출력을 찾아야 한다.  
1. 주문에 부가세와 배송비가 더해진다.
2. 정해진 파일 경로에서 애플리케이션의 설정 정보를 읽어 들인다.
3. 웹 애플리케이션에 누군가가 로그인한다.

(예상답)  
1. 주문내역총액 -> (총액 + 총액 * 부가세율) + 배송비
2. 파일 경로 -> 설정 정보
3. 로그인 정보 -> 로그인 처리(메모리 저장)

(연습문제)  
입력 칸에 들어온 문자열 값을 검증하고 18에서 150 사이의 정수로 바꿔야 하는 상황이다. 전체 변환은 다음과 같다.

문자열 입력 내용  
  -> [검증 및 변환]  
    -> {:ok, 값} | {:error, 원인}

"검증 및 변환"을 구성하는 개별 변환들을 작성하라.

(예상답)  
1. 문자열 검증(문자 여부 확인)
2. 숫자로 변환
3. 값 범위 확인(18 ~ 150)

(연습문제)  
"X 언어에는 파이프라인이 없는데요"에서 우리는 다음과 같은 코드를 썼다.  
```
const content = File.read(file_name);
const lines = find_matching_lines(content, pattern);
const result = truncate_lines(lines);
```
많은 사람이 객체 지향 코드를 짤 때 메서드 호출을 연결해서 쓴다.  
그래서 어쩌면 위 코드도 다음과 같이 바꾸고 싶을지도 모른다.  
```
cosnt result = content_of(file_name)
              .find_matching_lines(pattern)
              .truncate_lines();
```

두 가지 코드의 차이는 무엇인가? 여러분이 보기에 우리는 어느 쪽을 선호할 것 같은가?

(예상답)
아래 코드가 변수가 하나로 줄어들고 인자가 줄어들어 관리하기가 편함.  
하지만 유연성이 줄어듬. 다른 곳에서 조합해서 사용하기 제약이 생김.  
가독성은 아래가 더 좋지만, 유연성은 위가 더 좋아서 위의 코드를 선호할 것 같음.  

---
#### Topic31. 상속세

"당신이 원한 것은 바나나 하나였지만, 당신이 받은 것은 바나나를 들고 있는 고릴라와 정글 전체다." - 조 암스트롱(얼랭 창시자) -

객체지향언어로 프로그래밍 하는가? 상속을 사용하는가?  
아마 당신이 필요한 것은 상속이 아닐 것이다.  

상속의 문제는 결합도를 증가시킨 다는 것이다.  
만약 부모클래스를 상속하는 자식클래스를 사용자가 사용하였고 부모클래스를 개발한 개발자가 내용을 변경하면 이유도 모르고 자식클래스를 사용한 코드에서 문제가 발생한다.

상속을 사용하면서 너무 많은 계층을 나누려고 하면 편리하려고(코드 재사용) 상속을 했지만 오히려 더 복잡해져서 관리하기 힘들다.

#### 더 나은 대안

더는 상속을 쓸 필요가 없게 해주는 세 가지 기법
- 인터페이스와 프로토콜
- 위임
- 믹스인과 트레이트

##### 인터페이스와 프로토콜

대부분의 객체 지향 언어는 클래스가 특정한 동작을 구현한다고 지정할 수 있다.  
여러 동작을 지정할 수도 있는데, 예를 들어 Car 클래스가 Drivable 동작과 Locatable 동작을 구현한다고 할 수 있다.  

```java
public class Car implements Drivable, Locatable {
  //Car 클래스의 코드. 이 코드는 Drivable과 Locatable이 요구하는 기능을 모두 구현해야 한다.
```

Drivable, Locatable을 인터페이스라고 부르는 곳도 있고, 프로토콜, 트레이트라고 부르는 언어도 있다.(뒤에서 얘기할 트레이트와 같은 단어지만 다른 개념이다.)

인터페이스는 다음과 같이 정의한다.

```java
public interface Drivable {
  double getSpeed();
  void stop();
}

public interface Locatable {
  Coordinate getLocation();
  boolean locationIsValid();
}
```

인터페이스(프로토콜 등)가 강력한 까닭은 이들을 타입으로 사용할 수 있고, 해당 인터페이스를 구현하는 클래스라면 무엇이든 그 타입과 호환되기 때문이다.  
만약 Car와 Phone이 모두 Locatable인터페이스를 구현했다면 둘 다 Locatable한 것을 담는 리스트에 넣을 수 있다.

```java
List<Locatable> items = new ArrayList<>();

items.add(new Car(...));
items.add(new Phone(...));
items.add(new Car(...));
```

이 리스트를 처리할 때는 모든 원소가 getLocation과 locationIsValid를 구현했다는 것을 알고 있으므로 이를 활용할 수 있다.

```java
void printLocation(Locatable item) {
  if (item.locationIsValid() {
    print(item.getLocation().asString());
}

// ...

items.forEach(printLocation);
```

"다형성은 인터페이스로 표현하는 것이 좋다."

인터페이스와 프로토콜은 상속 없이도 다형성을 가져다준다.

#### 위임(의존 주입, Dependency Injection, DI)

상속은 개발자들이 점점 더 메서드가 많은 클래스를 만들도록 유도한다. 부모 클래스에 메서드가 20개 있으면 하위 클래스는 그중 딱 두 개만 사용하고 싶어도 필요없는 18개의 메서드까지 함께 자리잡는다.  
클래스가 자신의 인터페이스를 제어할 수 없게 되는 것이다.  
이런 문제는 흔히 찾아볼 수 있다.  
예를 들어 많은 영속성 프레임워크나 UI 프레임워크에서 애플리케이션 컴포넌트는 특정 기반 클래스를 상속해야만 한다.  
```
class Account < PersistenceBaseClass
end
```

이제 Account클래스는 영속성 클래스 API를 모두 달고 다녀야 한다. 이러는 대신 위임을 사용하자.  

```
class Account
  def initialize( ... )
    @repo = Persister.for(self)  //상속대신 생성자를 통한 의존주입 사용(합성이랑 무슨 차이지?)
  end

  def save
    @repo.save()
  end
end
```

이제 Account 클래스는 클라이언트에게 프레임워크의 API를 노출하지 않는다.

결합(상속을 통한 강결합)이 사라졌다.

##### "서비스에 위임하라. Has-A가 Is-A보다 낫다."

여기서 한 발짝 더 나아가면, Account가 왜 영속성에 관해 알아야 하는가?  
Account 클래스는 계정(account)에 관한 비즈니스 규칙을 적용하는 것이 원래 할 일 아닌가?  

```
class Account
  # 계정에 관련된 일만 함
end

class AccountRecord
  # Account를 감싸서 객체를 저장하거나 불러오는 기능을 함
end
```

이제는 진짜 결합이 사라졌다. 하지만 여기에는 계산서가 붙는다. 코드양이 증가한다.  
그중 일부는 틀에 박힌 코드일 것이다. 예를 들어 아마 모든 레코드 클래스에 '찾기' 메서드가 필요할 테니 일일이 메서드를 추가해 주어야 한다.  
이런 부분을 믹스인(mixin)과 트레이트(trait)가 하는 일이다.

#### 믹스인, 트레이트, 카테고리, 프로토콜 확장 등

믹스인의 기본발상 :  
클래스나 객체에 상속을 사용하지 않고 새로운 기능을 추가하여 확장하고 싶다.  
그래서 일련의 함수들을 만들고 여기에 이름을 붙인 다음, 이것으로 어떻게든 클래스나 객체를 확장한다.  
이 시점에서 여러분은 기존 클래스와 그에 덧붙이는 믹스인의 동작을 모두 합한 새로운 클래스나 객체를 만든 것이다.  


```
mixin CommonFinders {
  def find(id) { ... }
  def findAll() { ... }
}

class AccountRecord extends BasicRecord with CommonFinders
class OrderRecord   extends BasicRecord with CommonFinders
```

더 발전시켜서, 비즈니스 객체에 검증코드가 필요하다.

계정일 경우 검증은?
- 일방향 암호화한 비밀번호가 사용자가 입력한 것과 일치하는지 검증
- 계정을 생성할 때 사용자가 입력한 정보 검증
- 관리자가 사용자 상세 정보를 변경할 때 입력한 정보 검증
- 다른 시스템 컴포넌트가 계정에 추가한 정보 검증
- 데이터베이스에 저장하기 전에 데이터 일관성 검증

흔히 쓰이는 접근 방식은 하나의 클래스에 (비즈니스 객체 혹은 영속성 객체의 클래스에) 모든 검증을 다 가져다 붙인 후, 상황별로 플래그를 추가해서 적용할 검증 사항을 관리하는 것. 별로 이상적이지 않다.  

믹스인(합성)을 사용하여 각 상황에 맞는 전문화된 클래스를 만드는 것이 더 낫다고 생각한다.

```
class AccountForCustomer extends Account
  with AccountValidations, AccountCustomerValidations

class AccountForAdmin extends Account
  with AccountValidations, AccountAdminValidations
```

여기서는 두 파생 클래스 모두 계정 객체에 공통으로 적용해야 할 검증을 포함하고 있다.  

