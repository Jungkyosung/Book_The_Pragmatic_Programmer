빠른 변화 속도를 따라가려면 가능한 한 느슨하고 유연한 코드를 작성해야 한다. 그러지 않으면 코드는 금세 낡고 수정하기 어려워지고, 결국 기억 저편으로 사라진다.

되돌릴 수 있는 의사 결정을 내리는 구체적인 방법을 확인하자.

---
#### Topic28. 결합도 줄이기

"모든 것은 얽혀 있다."

결합도가 낮은 코드가 바꾸기 쉽다.

결합의 증상들
- 관계없는 모듈이나 라이브러리 간의 희한한 의존관계
- 한 모듈의 '간단한' 수정이 이와 관계없는 모듈을 통해 시스템 전역으로 퍼져 나가거나 시스템의 다른 곳에서 무언가를 깨뜨리는 경우
- 개발자가 수정하는 부분이 시스템에 어떤 영향을 미칠지 몰라 코드의 수정을 두려워하는 경우
- 변경 사항에 누가 영향을 받는지 파악하고 있는 사람이 없어서 결국 모든 사람이 참석해야 하는 회의

```
public void applyDiscount(customer, order_id, discount) {
  totals = customer
            .orders
            .find(order_id)
            .getTotals();
  totals.grandTotal = totals.grandTotal - discount;
  totals.discount = discount;
}
```
//바꿔야 한다면 어디를 바꿔야 할까?
//메서드 별로 구분해야 하나?
//어떻게 연결해야 할까요? 
//몰라도 되게 [할인적용]이라면 할인적용을 목적으로
//


고객 객체에서 해당하는 주문 컬렉션의 참조를 얻는다. 거기서 특정한 주문을 찾고, 찾은 주문의 합계를 얻는다. 
이 합계에서 얻은 주문 총액에서 할인액을 빼고, 합계에 저장된 할인액도 갱신한다.

이 코드는 고객에서 합계까지 다섯 단계의 추상화를 오간다. 결국 최상위 코드가 모든 것을 알아야 한다.
고객 객체는 주문 컬렉션을 노출하고, 이 주문 컬렉션에는 주문 아이디를 받아서 주문 객체를 반환하는 find 메서드가 있으며, 주문 객체는 totals 객체를 가지고 있는데, 
이 totals 객체에는 총액과 할인액을 읽거나 쓸 수 있는 접근자가 있다는 것까지 다 알아야 한다.

코드를 쓰거나 이해하기 위해 알아야 하는 것이 너무 많다.(? 그런가? 이런 생각을 못해봤는데)
설상가상 이 코드를 지원하기 위해 앞으로 바뀌면 안되는 것도 너무 많다.  
메서드나 속성들이 모두 연결되어 있다.  
이런 코드를 '열차 사고'라고 부른다.  
